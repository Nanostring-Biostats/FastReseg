---
title: "FastReseg to detect and correct segmentation error in spatial transcriptome data"
author: "Lidan Wu"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{FastReseg to detect and correct segmentation error in spatial transcriptome data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = '100%',
  fig.width=10, 
  fig.height=10
)
```

This tutorial below shows how to apply functions in `FastReseg` to perform segmentation error detection and correction in spatial transcriptome data. 

## Pipeline wrapper functions for streamline processing
For streamline processing of multiple FOVs of big dataset, one can use the pipeline wrapper functions provided in the `FastReseg` package without going through the individual steps shown in this tutorial. Please refer to the bottom section for [Example usage of pipeline wrapper functions] in this tutorial or the manual of each pipeline wrapper for the example usage.  

* `fastReseg_flag_all_errors()`: pipeline wrapper to pre-process data and flag cell segmentation error in a list of files for per-FOV transcript data.frame. 

* `fastReseg_full_pipeline()`: wrapper for entire resegmentation pipeline which extracts reference profiles, cutoffs from data and then use them to detect segmentation error and eventually perform correction; it can process a list of files for many FOVs.

* `fastReseg_perFOV_full_process()`: core wrapper for resegmentation pipeline using external provided reference profiles and cutoffs; it does segmentation error detection and correction and can process one transcript data.frame at a time. 

   + This function is particularly useful when one would like to try out the pipeline on one representative FOV quickly first and decide on the appropriate cutoffs before launching the processing of entire dataset. 

## Input data

The required inputs include:

* `counts`:  a cell-by-gene counts matrix for entire dataset. 

* `clust`: a vector of cluster assignments for each cell in `counts`; use `NULL` to automatically assign the cell cluster for each cell based on maximum transcript score of given the provided `refProfiles`.

* `refProfiles`: a gene-by-cluster matrix of cluster-specific expression profiles; default = `NULL` to use external cluster assignments.

* `transDF_fileInfo`: a data.frame with each row for each individual file of per-FOV transcript data.frame, columns include the file path of per FOV transcript data.frame file, annotation columns like `slide` and `fov` to be used as prefix when creating unique cell_ID across entire dataset.
   + when `NULL`, use the transcript data.frame `transcript_df` directly.

There must be at least one of the `clust` and `refProfiles` provided to run the `FastReseg` pipeline. All the spatial coordinates and distance are in the units of micron for consistency. Please refer to example data coming with the package to see how it looks like. 

```{r input_data}
# load example input data from package
library(FastReseg)

# get cell-by-gene `counts`
data("example_CellGeneExpr")
counts <- example_CellGeneExpr

# get cluster assignment `clust`
data("example_clust")
clust <- example_clust

# get cluster-specific reference profiles `refProfiles`
data("example_refProfiles")
refProfiles <- example_refProfiles

# create `transDF_fileInfo` for multiple per FOV transcript data.frame 
# coordinates for each FOV, `stage_x` and `stage_y`, should have units in micron.
transDF_fileInfo <- data.frame(file_path = c("data/Run4104_FOV001__complete_code_cell_target_call_coord.csv",
                                             "data/Run4104_FOV002__complete_code_cell_target_call_coord.csv"),
                               slide = c(1, 1),
                               fov = c(1,2),
                               stage_X = 1000*c(5.13, -2.701),
                               stage_Y = 1000*c(-0.452, 0.081))
```

When preparing the per-FOV data.frame outside the pipeline wrappers, one can read in each per-FOV file and process it with `prepare_perFOV_transDF()` function to get the unique IDs for cells and transcripts as well as converting the local coordinates in pixel for each FOV to a global coordinate in micro for entire dataset. 

```{r prep_FOV_file, eval = FALSE}
## not to run this chunk

#  process 1st file in the `transDF_fileInfo` entry 
idx = 1
rawDF <- read.csv(transDF_fileInfo[idx, 'file_path'])

transcript_df_all <- prepare_perFOV_transDF(each_transDF = rawDF, 
                                            fov_centerLocs = unlist(transDF_fileInfo[idx, c('stage_X', 'stage_Y')]),
                                            prefix_vals = unlist(transDF_fileInfo[idx, c('slide', 'fov')]), 
                                            pixel_size = 0.12, # micron per pixel 
                                            zstep_size = 0.8, # micron per z step 
                                            transID_coln = NULL, # use row index 
                                            transGene_coln = 'target', # gene name
                                            cellID_coln = 'CellId', # cell label unique at FOV level 
                                            spatLocs_colns = c('x', 'y', 'z'), # column names for spatial coordinates in pixel for each FOV
                                            extracellular_cellID = 0, # set this to the cell ID for extracellular transcript, use NULL if your data only contains intracellular transcripts 
                                            drop_original = TRUE) # set to FALSE if want to have columns for original cell ID and spatial coordinates returned in the data.frame

# we would focus on intracellular transcripts for downstream segmentation error detection
transcript_df <- transcript_df_all[["intraC"]]
```

Here is an example of per-FOV transcript data.frame with necessary columns for:  

* `target` for gene name; 

* `x`, `y` and optional `z` for spatial coordinates of each transcript;  

* `UMI_cellID` for cell ids of current cell segmentation and must be unique across all FOVs of the same dataset; 

   + When not available, `prepare_perFOV_transDF()` function would use per-FOV unique `CellId` and the provided `prefix_colns = c('slide', 'fov')` to generate `UMI_cellID` that would be unique across the entire dataset. Pipeline wrappers, `fastReseg_flag_all_errors()` and `fastReseg_full_pipeline()`, would also generate unique cell ids in same manner for the multiple files listed in `transDF_fileInfo`. 
   
* `UMI_transID`: transcript ids that are unique across the dataset; 

   + By default, the `prepare_perFOV_transDF()` function and the 2 pipeline wrappers would use row index of transcript in each per-FOV transcript data.frame and `UMI_cellID` to create `UMI_transID` that would be unique across the entire dataset.

```{r, echo=FALSE, results ='asis'}
data(mini_transcriptDF)
transcript_df <- mini_transcriptDF
knitr::kable(head(transcript_df))
```

## modular functions for individual tasks
### Preprocess on whole dataset 

First, one needs to preprocess at whole dataset scale to get appropriate baselines and cutoffs for downstream segmentation error detection and correction at individual FOV level. This could be done using `runPreprocess()` function.

```{r preprocess, eval=FALSE}
## not to run this code chunk

prep_res <- runPreprocess(
  counts = counts, 
  
  ## when certain cell typing has been done on the dataset with initial cell segmentation,  
  # set `refProfiles` to NULL, but use the cell typing assignment in `clust`
  clust = clust, 
  refProfiles = NULL,
  
  ## if celll typing has NOT been done on the dataset with initial cell segmentation, 
  # set `clust` to NULL, but use cluster-specific profiles in `refProfiles` instead
  
  ## of note, when `refProfiles is not NULL, genes unique to `counts` but missing in `refProfiles` would be omitted from downstream analysis.  
  
  # cutoffs for transcript scores and number for cells under each cell type
  # if NULL, calculate those cutoffs from `counts`, `clust` and/or `refProfiles` across the entire dataset
  score_baseline = NULL, 
  lowerCutoff_transNum = NULL, 
  higherCutoff_transNum= NULL, 
  imputeFlag_missingCTs = FALSE, # flag to impute transcript score and number cutoffs for cell types in `refProfiles` but missing in `clust`
  
  # genes in `counts` but not in `refProfiles` and expect no cell type dependency, e.g. negative control probes
  ctrl_genes = NULL,
  # cutoff of transcript score to separate between high and low score transcript classes, used as the score values for `ctrl_genes` 
  svmClass_score_cutoff = -2,
  
  # distance cutoff for neighborhood searching at molecular and cellular levels, respectively
  # if NULL, calculate those distance cutoffs from the first transcript data.frame provided (slow process)
  # if values provided in input, no distance calculation would be done 
  molecular_distance_cutoff = 2.7,
  cellular_distance_cutoff = 20,
  
  transcript_df = NULL, # take a transcript data.frame as input directly when `transDF_fileInfo = NULL`
  transDF_fileInfo = transDF_fileInfo, # data.frame info for multiple perFOV transcript data.frame files
  filepath_coln = 'file_path', 
  prefix_colns = c('slide','fov'), 
  fovOffset_colns = c('stage_X','stage_Y'), 
  
  pixel_size = 0.18, # in micron per pixel
  zstep_size = 0.8, # in micron per z step
  transID_coln = NULL,
  transGene_coln = "target",
  
  # cell ID column in the provided transcript data.frame, which is the 1st file in `transDF_fileInfo` in this example
  cellID_coln = 'CellId', 
  spatLocs_colns = c('x','y','z'), 
  extracellular_cellID = 0 # cell ID for extracellular transcript 
)


## variables passing to the downstream pipeline
# gene x cell type matrix of transcript score 
score_GeneMatrix <- prep_res[['score_GeneMatrix']]

# per cell transcript score baseline for each cell type
score_baseline <- prep_res[['cutoffs_list']][['score_baseline']]

# upper and lower limit of per cell transcript number for each cell type
lowerCutoff_transNum <- prep_res[['cutoffs_list']][['lowerCutoff_transNum']]
higherCutoff_transNum <- prep_res[['cutoffs_list']][['higherCutoff_transNum']]

# distance cutoffs for neighborhood at cellular and molecular levels
cellular_distance_cutoff <- prep_res[['cutoffs_list']][['cellular_distance_cutoff']]
molecular_distance_cutoff <- prep_res[['cutoffs_list']][['molecular_distance_cutoff']]
```

`runPreprocess()` function returns a list of outputs among which `score_GeneMatrix` and `cutoffs_list` would be passed to downstream resegmentation pipeline. 

```{r description_runPreprocess, echo=FALSE, results ='asis'}
df1 <- data.frame(variable = c("`clust`", "`refProfiles`", "`baselineData`", "`cutoffs_list`","", "`ctrl_genes`", "`score_GeneMatrix`", "`processed_1st_transDF`"),
                  description = c("vector of cluster assignments used in caculating `baselineData`", 
                                  "gene X cluster matrix of cluster-specific reference profiles to use in resegmenation pipeline", 
                                  "list of two matrice in cluster X percentile format for the cluster-specific percentile distribution of per cell value in terms of transcript score and number, respectively", 
                                  "*list of cutoffs to use in resegmentation pipeline:*", 
                                  "* `score_baseline`: named vector of per cell type minimal score required to call certain cell type of high enough confidence.\n
                                  * `lowerCutoff_transNum`: named vector of per cell type minimal transcript number per cell to keep query cell as it is.\n
                                  * `higherCutoff_transNum`: named vector of per cell type maxmium transcript number per cell to keep query cell as it is without merging to neighbor cell of consistent cell type.\n
                                  * `cellular_distance_cutoff`: maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, unit in micron.\n
                                  * `molecular_distance_cutoff`: maximum molecule-to-molecule distance within connected transcript group, unit in micron.", 
                                  "vector of control genes whose transcript scores are set to fixed value for all cell types, return when `ctrl_genes` is not `NULL`.", 
                                  "gene x cell-type score matrix to use in resegmenation pipeline, the scores for `ctrl_genes` are set to be the same as `svmClass_score_cutoff`", 
                                  "list of 2 elements for the intracellular and extracellular transcript data.frame of the processed outcomes of 1st transcrip file"))

pander::pander(df1, keep.line.breaks = TRUE, style = 'grid', justify = 'left', split.cells = c("40%", "60%"))
```

##### initial cell typing and control genes

The above example of `runPreprocess()` is using `clust` as input, assuming the single-cell dataset that has gone through certain type of cell typing algorithm using the initial cell segmentation. In case of no cell typing has been done on the input dataset, one could set `clust` to `NULL`, but provide cluster-specific profiles in `refProfiles` as input. The `runPreprocess()` function would do quick supervised cell typing on the input dataset given the initial cell segmentation. 
Of note, when `refProfiles` is provided to `runPreprocess()` , genes unique to `counts` but missing in `refProfiles` would be omitted from downstream analysis. To include all genes in `counts`, one could set those unique genes as `ctrl_genes` whose expression profiles are expected to either show no strong cell type dependency or be a very small fraction of the total per cell expression. Alternatively, one can do a quick cell typing using the `get_baselineCT()` function as the following before feeding the `clust` to `runPreprocess()` with `refProfiles` set to `NULL`.

```{r get_initial_clust, eval = FALSE}
## not to run this chunk

baselineData <- get_baselineCT(refProfiles = refProfiles, counts = counts, clust = NULL)
clust <- baselineData[['clust_used']]
```

##### distance cutoffs defining neighborhood

During the pre-processing step, one would also need to define the distance cutoffs for downstream neighborhood search during segmentation refinement. These cutoffs could be defined based on prior knowledge directly or calculated from the provided `transcript_df` using either `runPreprocess()` or `choose_distance_cutoff()` function. 

* `cellular_distance_cutoff` is defined as maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact. 

   + When set to `NULL` in the input of `runPreprocess()` function, the function calculates average 2D cell diameter from the input transcript data.frame and use 2 times of the mean cell diameter as `cellular_distance_cutoff`.

* `molecular_distance_cutoff` is defined as maximum molecule-to-molecule distance within connected transcript groups belonging to same source cells. One can decide this value based on the expected spot density within each cell. 

   + When set to `NULL` in the input of `runPreprocess()` function, the function would first randomly choose `sampleSize_cellNum = 2500` number of cells from `sampleSize_nROI = 10` number of randomly picked ROIs with search radius to be 5 times of `cellular_distance_cutoff`, and then calculate the minimal molecular distance between picked cells.
   
Below is an example to calculate distance cutoff from the input transcript data.frame outside the `runPreprocess()` function using `choose_distance_cutoff()`, which offers more control on the distance cutoff calculation setup and may allow faster calculation than doing it within the `runPreprocess()` function.

```{r distance_cutoff, eval = TRUE}
## for demonstration purpose, use the example `mini_transcriptDF`
data(mini_transcriptDF)
transcript_df <- mini_transcriptDF


## get distance cutoffs
distCutoffs <- choose_distance_cutoff(
  # allow to choose any transcript data.frame that is representative to entire dataset
  # while `runPreprocess()` uses the first provided transcript data.frame in the file list
  transcript_df, 
  
  # allow to use 2D spatial coordinates here since transcript is more dense in 2D, 
  # 2D calculation of distance cutoff would be faster than 3D calculation used in `runPreprocess()` 
  spatLocs_colns = c('x','y'), 
  
  transID_coln = 'UMI_transID',
  cellID_coln = 'UMI_cellID', 
  extracellular_cellID = NULL, 
  
  # flag to calculate `molecular_distance_cutoff` from input data, slower process
  run_molecularDist = TRUE,
  # configs on random sampling of cells
  sampleSize_nROI = 10, 
  sampleSize_cellNum = 2500, 
  seed = 123 )

molecular_distance_cutoff <- distCutoffs[['molecular_distance_cutoff']]
cellular_distance_cutoff <- distCutoffs[['cellular_distance_cutoff']]
```

Empirically, let's set 20um and 2um values for the two cutoffs, respectively, for dataset on human tissue with 100+ plex target gene in panel. 

```{r input_cutoff}
cellular_distance_cutoff = 20
molecular_distance_cutoff = 2
```

```{r input_cutoffs, echo=TRUE}
## for demonstration purpose, use the saved baseline values paired with example `mini_transcriptDF`
data("example_baselineCT")

score_baseline = example_baselineCT[["span_score"]][, "25%"]
lowerCutoff_transNum = example_baselineCT[["span_transNum"]][, "25%"]
higherCutoff_transNum = example_baselineCT[["span_transNum"]][, "50%"]

# calculate log-likelihood of each gene under each cell type and center the score matrix on per gene basis
score_GeneMatrix <- scoreGenesInRef(genes = intersect(colnames(counts), rownames(refProfiles)), 
                                    ref_profiles = pmax(refProfiles, 1e-5))
```

### Processing indvidual FOV in parallel 

> The following sections would operate on one per-FOV transcript data.frame at a time. For processing on multiple FOVs, please either refer to the provided pipeline wrapper functions or create your own wrapper around the code chucks listed below. 

#### Flag cells with putative segmentation errors

Now we are ready to evaluate each cell on their potential to have cell segmentation errors. 

```{r eval_cellSeg, fig.show='hold', fig.width=8, fig.height=4}
outs <- runSegErrorEvaluation(
  score_GeneMatrix= score_GeneMatrix, 
  transcript_df = transcript_df, 
  cellID_coln = 'UMI_cellID', 
  transID_coln = 'UMI_transID',
  transGene_coln = 'target',
  spatLocs_colns = c('x','y','z'),
  # cutoff of transcript number to do spatial modeling
  flagModel_TransNum_cutoff = 50) 

modStats_ToFlagCells <- outs [['modStats_ToFlagCells']]
transcript_df <- outs[['transcript_df']]
rm(outs)


# transcript data.frame with additional columns for cell types and transcript scores under current cell segmentation 
head(transcript_df, n = 3L)

# model statistics
head(modStats_ToFlagCells)

# histogram for spatial dependency in all cells
hist(modStats_ToFlagCells$`lrtest_-log10P`, breaks = "FD", 
     main = paste0("Histogram of spatial dependency, mean = ", 
                   round(mean(modStats_ToFlagCells$`lrtest_-log10P`), 2)))
abline(v = mean(modStats_ToFlagCells$`lrtest_-log10P`), col="red", lwd=3, lty=2)

```

The function above returns the statistics for evaluating each cell for spatial dependent model against null model. Based on the P value, `lrtest_Pr` or the negative log10 value `lrtest_-log10P`, one can select for cells with strong spatial dependency in transcript score profile. Those cells are likely to contain contaminating transcripts for neighbor cells. 

```{r flag_cells}
# cutoff to flag for cells with strong spatial dependcy in transcript score profiles
flagCell_lrtest_cutoff  = 5

modStats_ToFlagCells[['flagged']] <- (modStats_ToFlagCells[['lrtest_-log10P']] > flagCell_lrtest_cutoff )
flagged_cells <- modStats_ToFlagCells[['UMI_cellID']][modStats_ToFlagCells[['flagged']]]

message(sprintf("%d cells, %.4f of all evaluated cells, are flagged for resegmentation with lrtest_-log10P > %.1f.", 
                 length(flagged_cells), length(flagged_cells)/nrow(modStats_ToFlagCells), flagCell_lrtest_cutoff))
```
```{r fig_flagCells, fig.show='hold'}
# spatial plot some flagged cells with various degrees of spatial dependency in transcript profiles
rownames(modStats_ToFlagCells) <- modStats_ToFlagCells$UMI_cellID
cells_to_plot <- modStats_ToFlagCells[flagged_cells, 'lrtest_-log10P']
names(cells_to_plot) <- flagged_cells
cells_to_plot <- cells_to_plot[order(cells_to_plot, decreasing = T)]
cells_to_plot <- cells_to_plot[seq(1, length(cells_to_plot), by = 25)]

plotSpatialScoreMultiCells(chosen_cells = names(cells_to_plot), 
                           cell_labels = round(cells_to_plot, 2), 
                           transcript_df = transcript_df, 
                           cellID_coln = "UMI_cellID", 
                           transID_coln = "UMI_transID",
                           score_coln = "score_tLLR_maxCellType", 
                           spatLocs_colns = c("x","y"),
                           point_size = 0.5)
```

#### Identify wrongly segmented transcript groups

Under the assumption that the contamination from neighbor cells would result in patches of low-score transcript groups in space, we first separate the transcripts within each flagged cells into high and low score groups and then divide the transcripts of low score into different spatially connected groups assuming they might arise from different source cells in neighborhood. 

```{r flag_transcripts}
# cutoff of transcript score to separate between high and low score transcripts 
svmClass_score_cutoff = -2 

# a list of arguments to pass to `e1071::svm` function to define the strength of spatial connectivity 
svm_args = list(kernel = "radial", 
                scale = FALSE, 
                gamma = 0.4)

groupDF_ToFlagTrans <- runTranscriptErrorDetection(chosen_cells = flagged_cells,
                                                   score_GeneMatrix = score_GeneMatrix, 
                                                   transcript_df = transcript_df, # include column for transcript score under current cell segmentation
                                                   cellID_coln = "UMI_cellID", 
                                                   transID_coln = "UMI_transID", 
                                                   # column for transcript score in current cell segment
                                                   score_coln = 'score_tLLR_maxCellType',
                                                   spatLocs_colns = c("x","y","z"),
                                                   model_cutoff = 50, 
                                                   score_cutoff = svmClass_score_cutoff, 
                                                   svm_args = svm_args,
                                                   # maximum molecule-to-molecule distance within same transcript group 
                                                   distance_cutoff = molecular_distance_cutoff, 
                                                   # use "dbscan" method for spatial grouping of transcripts, alternative to use "delaunay"
                                                   groupTranscripts_method = "dbscan")

head(groupDF_ToFlagTrans)
  
```   

The function above returns a transcript data.frame for the flagged cells with results in spatial-dependent score classification and spatial group ID assignment. 

* `SVM_class` shows the transcript score classification,  `0` for low score below cutoff, `1` for high score above cutoff; the corresponding decision values of svm model output are listed in `DecVal`. 

   + One can use `SVM_class` to select all low-score transcript groups and then remove them from the original transcript data.frame all together. This approach effectively trims off the putative contaminating transcripts from current cell segmentation without more complex refinement.

* `connect_group` shows the spatial group ID assigned to each transcripts, while the corresponding cell types with maximum transcript scores under the given transcript groups are listed in `group_maxCellType`. `0` for transcript group with high score under the putative cell type of current cell segmentation.

* `tmp_cellID` is the column for new cell IDs with which each identified low-score transcript group is assigned with a unique new name to separate from its original cell. Transcript groups with high score would keep the same cell ID as the corresponding original cells.

```{r fig_flagTranscripts, fig.show='hold'}
# spatial plot for `SVM_class`, the high vs. low score classification of transcript groups in flagged cells
plotSpatialScoreMultiCells(chosen_cells = names(cells_to_plot),
                           cell_labels = round(cells_to_plot, 2),
                           transcript_df = groupDF_ToFlagTrans,
                           cellID_coln = "UMI_cellID",
                           transID_coln = "UMI_transID",
                           score_coln = "SVM_class",
                           spatLocs_colns = c("x","y"),
                           point_size = 0.5, 
                           plot_discrete = T, 
                           title = "transcript score classification")

# spatial plot for `connect_group`, the spatial group ID for transcripts within each cell
plotSpatialScoreMultiCells(chosen_cells = names(cells_to_plot),
                           cell_labels = round(cells_to_plot, 2),
                           transcript_df = groupDF_ToFlagTrans,
                           cellID_coln = "UMI_cellID",
                           transID_coln = "UMI_transID",
                           score_coln = "connect_group",
                           spatLocs_colns = c("x","y"),
                           point_size = 0.5, 
                           plot_discrete = T, 
                           title = "spatial connected transcript groups")

# spatial plot for `group_maxCellType`, the cell type with maximum score for each transcript group
plotSpatialScoreMultiCells(chosen_cells = names(cells_to_plot),
                           cell_labels = round(cells_to_plot, 2),
                           transcript_df = groupDF_ToFlagTrans,
                           cellID_coln = "UMI_cellID",
                           transID_coln = "UMI_transID",
                           score_coln = "group_maxCellType",
                           spatLocs_colns = c("x","y"),
                           point_size = 0.5, 
                           plot_discrete = T,
                           title = "putative cell type for each transcript group")
```

#### Get ready for segmentation refinement  

If one would like to perform more sophisticated cell segmentation refinement than simple trimming for all low-score transcript groups, one should update the original transcript data.frame with the new cell IDs and maximum cell types from the output of `runTranscriptErrorDetection()` function to keep those identified low-score transcript groups separated from their original cell segment assignment before further segmentation refinement. 
   
```{r prep_resegDF}
# update the transcript_df with flagged transcript_group
reseg_transcript_df <- merge(transcript_df, 
                             groupDF_ToFlagTrans[, c("UMI_transID", 'connect_group','tmp_cellID','group_maxCellType')], 
                             by = "UMI_transID", all.x = TRUE)
# fill in the missing values for unflagged cells
tmp_idx <- which(is.na(reseg_transcript_df[['connect_group']]))
reseg_transcript_df[['connect_group']][tmp_idx] <- rep(0, length(tmp_idx))
reseg_transcript_df[['tmp_cellID']][tmp_idx] <- reseg_transcript_df[["UMI_cellID"]][tmp_idx]
reseg_transcript_df[['group_maxCellType']][tmp_idx] <- reseg_transcript_df[['tLLR_maxCellType']][tmp_idx]
rm(tmp_idx)

# cells or group IDs for neighborhood evaluation 
groups_to_reseg <- unique(groupDF_ToFlagTrans[which(groupDF_ToFlagTrans[['connect_group']]!=0),][['tmp_cellID']])

# `tmp_cellID` and `group_maxCellType` now contains info for all cells including the identified transcript groups 
head(reseg_transcript_df, n = 3L)
```     

#### Perform segmentation refinement

For more sophisticated cell segmentation refinement, we first evaluate the neighborhood environment of each low-score transcript groups in terms of their goodness of fit to nearby potential source cells, and then determine the corresponding resegmentation operation by comparing the neighborhood analysis results with the baseline data for each cell type derived from the original dataset. Lastly, we apply those resegmentation operations to the original transcript data.frame to get the refined segmentation outcomes. Each identified low-score transcript group may experience the following refinement operation: trimming (removing to extracellular space), splitting (keeping as new cell ID by itself), or merging (assigning same cell ID as that of neighboring cells/transcript groups of same cell type).

```{r segment_refinement}
finalRes <- runSegRefinement(
  score_GeneMatrix = score_GeneMatrix,  
  chosen_cells = groups_to_reseg, 
  reseg_transcript_df = reseg_transcript_df, 
  reseg_cellID_coln = "tmp_cellID", 
  reseg_celltype_coln = "group_maxCellType", 
  transID_coln = "UMI_transID",
  transGene_coln = "target", 
  transSpatLocs_coln = c('x','y','z'),
  score_baseline = score_baseline, 
  lowerCutoff_transNum = lowerCutoff_transNum, 
  higherCutoff_transNum= higherCutoff_transNum, 
  neighbor_distance_xy = cellular_distance_cutoff,
  distance_cutoff = molecular_distance_cutoff,
  
  # apply spatial constraint on cell merging vs. splitting 
  # default to "leidenCut" for decision based on Leiden clustering of transcript coordinates, alternative use "geometryDiff" for geometric analysis 
  spatialMergeCheck_method = "leidenCut", 
  # list of leiden clustering configuration to pass to `igraph::cluster_leiden()` function
  leiden_config = list(objective_function = "CPM",
                       resolution_parameter = 1,
                       beta = 0.01,
                       n_iterations = 200), 
  # minimal percentage of transcripts shared membership between query cell and neighbor cells in leiden clustering results for a valid merging event
  cutoff_spatialMerge = 0.5,
  
  return_intermediates = TRUE, # flag to return intermediate outputs for neighborhood evaluation and resegmentation actions
  return_perCellData = TRUE,  # flag to return additional per cell data.frame and expression matrix
  includeAllRefGenes = FALSE # flag to include all genes in `score_GeneMatrix` in the returned `updated_perCellExprs` with missing genes of value 
)


# updated transcript data.frame with `updated_cellID` column reflecting the new transcript assignment to cells after refinement
# only includes transcripts that are intracellular in original segmentation and are genes in `score_GeneMatrix` 
updated_transDF <- finalRes[["updated_transDF"]]
head(updated_transDF, n = 3L)

# updated per cell data.table after refinement, with resegmentation operation recorded in `reSeg_action`
updated_perCellDT <- finalRes[['updated_perCellDT']]
head(updated_perCellDT)


table(updated_perCellDT[['reSeg_action']])

```  

`runSegRefinement()` function returns a list of outputs with updated cell segmentation that could be used in further single cell analysis.  

```{r description_runSegRefinement, echo=FALSE, results ='asis'}
df2 <- data.frame(variable = c("`updated_transDF`", "`neighborhoodDF_ToReseg`", "`reseg_actions`", "", "`updated_perCellDT`", "`updated_perCellExprs`"),
                  description = c("the updated transcript_df with `updated_cellID` and `updated_celltype` columns reflecting the new segmentation outcomes`", 
                                  "data.frame for neighborhood enviornment of low-score transcript groups, output of `neighborhood_for_resegment_spatstat()` function, return when `return_intermediates = TRUE`", 
                                  "*list of 4 elements describing how the resegmenation would be performed on `reseg_transcript_df` by the group assignment of transcripts listed in `reseg_cellID_coln`, return when `return_intermediates = TRUE`*", 
                                  "* `cells_to_discard`: a vector of cell ID that should be discarded during resegmentation.\n
                                  * `cells_to_update`: a named vector of cell ID whether the cell_ID in name would be replaced with new cell_ID in value.\n
                                  * `cells_to_keep`: a vector of cell ID that should be kept as it is.\n
                                  * `reseg_full_converter`: a single named vector of cell ID to update the original cell ID, assign `NA` for `cells_to_discard`.\n", 
                                  "per cell data.table with mean spatial coordinates, new cell type and resegmentation action after resegmentation, return when `return_perCellData = TRUE`", 
                                  "gene x cell count sparse matrix for updated transcript data.frame after resegmentation, return when `return_perCellData = TRUE`"))

pander::pander(df2, keep.line.breaks = TRUE, style = 'grid', justify = 'left', split.cells = c("40%", "60%"))
```

##### Visualize example resegmentation outcomes 

Let's check on a few cells which got changed by the segmentation refinement process. 

```{r fig_newSeg, fig.show='hold'}
# choose example cells got segmentation refinement operations of various kinds
trimmed_cells_to_plot <- updated_perCellDT[reSeg_action == "trim" & updated_cellID %in% names(cells_to_plot), updated_cellID]
changes_to_plot <- updated_perCellDT[!reSeg_action %in% c("none", "trim") | updated_cellID %in% trimmed_cells_to_plot , .SD, .SDcols = c('updated_cellID', 'reSeg_action')]

changes_to_plot <- merge(changes_to_plot, 
                         unique(updated_transDF[updated_transDF[['updated_cellID']] %in% changes_to_plot[['updated_cellID']], c('UMI_cellID', 'updated_cellID')]))
changes_to_plot[, oriCellNum_in_newCell := .N, by = updated_cellID ]
changes_to_plot[, newCellNum_from_oriCell := .N, by = UMI_cellID]

## segmentation changes for the selected cells with original cell_ID in `UMI_cellID` column
print(changes_to_plot[order(reSeg_action, - newCellNum_from_oriCell), ])


# get all transcript in the source cells for plotting
transDF_to_plot <- merge(reseg_transcript_df[reseg_transcript_df[["UMI_cellID"]] %in% changes_to_plot[['UMI_cellID']], ], 
                         updated_transDF[updated_transDF[["UMI_cellID"]] %in% changes_to_plot[['UMI_cellID']], ], all.x = T)

# label changed with respect to original cell segmentation
trim_idx <- which(is.na(transDF_to_plot[['updated_cellID']]))
alter_idx <- which(transDF_to_plot[['updated_cellID']] != transDF_to_plot[['UMI_cellID']])

transDF_to_plot[['changed']] <- 'none'
transDF_to_plot[['changed']][alter_idx] <- 'move_to_others'
transDF_to_plot[['changed']][trim_idx] <- 'trim'

# spatial plot for modification on original source cells
cells_to_plot2 <- unique(changes_to_plot[['UMI_cellID']])
plotSpatialScoreMultiCells(chosen_cells = cells_to_plot2,
                           cell_labels = round(modStats_ToFlagCells[cells_to_plot2, 'lrtest_-log10P'], 2),
                           transcript_df = transDF_to_plot,
                           cellID_coln = "UMI_cellID",
                           transID_coln = "UMI_transID",
                           score_coln = "changed",
                           spatLocs_colns = c("x","y"),
                           point_size = 0.5, 
                           plot_discrete = T,
                           title = "examples of orignal cells got trimmed or split")

```
```{r fig_merge, fig.show='hold',   fig.width=8, fig.height=4}
# spatial plot for new cells merged from multiple original cells
cells_to_plot2 <- changes_to_plot[oriCellNum_in_newCell >1,]
fig <- plotSpatialScoreMultiCells(chosen_cells = cells_to_plot2[['updated_cellID']],
                                  cell_labels = cells_to_plot2[['reSeg_action']],
                                  transcript_df = transDF_to_plot,
                                  cellID_coln = "updated_cellID",
                                  transID_coln = "UMI_transID",
                                  score_coln = "UMI_cellID",
                                  spatLocs_colns = c("x","y"),
                                  point_size = 1, 
                                  plot_discrete = T,
                                  title = "examples of new cells merged from multiple orignal cells")	
fig <- fig + ggplot2::scale_color_brewer(palette = "Dark2")
print(fig)
``` 

## Example usage of pipeline wrapper functions

While the modular functions used above offer flexibility in usage, `FastReseg` package provides 3 different pipeline wrappers for streamline processing as listed below. For more example usages and description, please refer to the manuals of those wrapper functions. 

### Core wrapper for perFOV processing 

The core wrapper function, `fastReseg_perFOV_full_process()`could process a `transcript_df` through the full pipeline as listed above. One can pick one representative FOV and process it with this wrapper function to evaluate and correct the segmentation errors in the data quickly before launching the processing of entire dataset which might take longer time when there are many FOVs. 

```{r perFOV_wrapper, eval = FALSE}
data(mini_transcriptDF)
extracellular_cellID <- mini_transcriptDF[which(mini_transcriptDF$CellId ==0), 'cell_ID']

res1 <- fastReseg_perFOV_full_process(score_GeneMatrix = score_GeneMatrix, 
                                      transcript_df = mini_transcriptDF, 
                                      transID_coln = 'UMI_transID',
                                      transGene_coln = "target",
                                      cellID_coln = 'UMI_cellID', 
                                      spatLocs_colns = c('x','y','z'), 
                                      extracellular_cellID = extracellular_cellID, 
                                      flagModel_TransNum_cutoff = 50, 
                                      flagCell_lrtest_cutoff = flagCell_lrtest_cutoff,
                                      svmClass_score_cutoff = svmClass_score_cutoff, 
                                      molecular_distance_cutoff = molecular_distance_cutoff,
                                      cellular_distance_cutoff = cellular_distance_cutoff,
                                      score_baseline = score_baseline, 
                                      lowerCutoff_transNum = lowerCutoff_transNum, 
                                      higherCutoff_transNum = higherCutoff_transNum,
                                      # default to "dbscan" for spatial grouping of transcripts, alternative to use "delaunay"
                                      groupTranscripts_method = "dbscan",
                                      # default to "leidenCut" for decision based on Leiden clustering of transcript coordinates, alternative to use "geometryDiff" for geometric analysis
                                      spatialMergeCheck_method = "leidenCut", 
                                      cutoff_spatialMerge = 0.5,
                                      return_intermediates = TRUE,
                                      return_perCellData = TRUE, 
                                      includeAllRefGenes = TRUE)

``` 

### Cell-level segmentation detection across multi-FOV dataset

### Full pipeline segmentation detection and refinement across multi-FOV dataset



## Session Info

```{r sessioninfo}
sessionInfo()
```
