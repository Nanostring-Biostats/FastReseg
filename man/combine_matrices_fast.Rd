% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fastReseg_full_pipeline.R
\name{combine_matrices_fast}
\alias{combine_matrices_fast}
\title{combine_matrices_fast}
\usage{
combine_matrices_fast(
  matrix_list,
  bind = c("cbind", "rbind"),
  fill = 0,
  output_type = c("auto", "dense", "sparse")
)
}
\arguments{
\item{matrix_list}{A list of matrices to combine. All matrices must have non-NULL dimension names.
Matrices can be either sparse (\code{Matrix::sparseMatrix}) or dense (\code{base::matrix}). Mixed inputs are supported
according to \code{output_type}.}

\item{bind}{Character string, \code{"cbind"} or \code{"rbind"}. Controls the bind direction:
\itemize{
\item \code{"cbind"}: align \strong{rows} (union of rownames) then column-bind. \strong{Rownames must be unique}; colnames may be duplicated.
\item \code{"rbind"}: align \strong{columns} (union of colnames) then row-bind. \strong{Colnames must be unique}; rownames may be duplicated.
}}

\item{fill}{Value to fill missing entries introduced by alignment. Default \code{0}.
\itemize{
\item If \code{output_type = "sparse"} (or all inputs are sparse) and \code{fill = NA}, the function sets \code{fill = 0} with a warning.
\item If \code{fill != 0} and sparse output is requested, the function converts to dense and warns.
}}

\item{output_type}{One of \code{"auto"}, \code{"dense"}, \code{"sparse"}. Controls the output class.
\itemize{
\item \code{"auto"}: all sparse → sparse; all dense → dense; mixed → sparse \strong{only when} \code{fill == 0}, otherwise dense.
\item \code{"dense"}: convert any sparse inputs to dense and return a dense matrix.
\item \code{"sparse"}: convert any dense inputs to sparse and return a sparse matrix. If \code{fill != 0}, converts to dense with warning.
}}
}
\value{
A combined matrix:
\itemize{
\item If \code{output_type} resolves to sparse, returns a \code{Matrix::sparseMatrix} (typically \code{dgCMatrix}).
\item If \code{output_type} resolves to dense, returns a base R \code{matrix}.
}
}
\description{
Efficiently combines a list of matrices by aligning along the necessary axis and then binding.
}
\details{
\itemize{
\item Alignment is performed on the axis specified by \code{bind}, and \strong{names on the aligned axis must be unique} for correctness.
\item The non-aligned axis \strong{may contain duplicated names}, which are preserved through binding.
\item Missing rows/columns introduced by alignment are filled with \code{fill}. For sparse outputs, missing entries are zeros.
\item If \code{fill = NA} and sparse output is selected, \code{fill} is replaced by \code{0} with a warning. If \code{fill != 0} and sparse output
is requested, the function converts to dense (with a warning) to represent non-zero fills.
}
}
\examples{
## --- Dense matrices, rbind ---
A2 <- matrix(11, 2, 2, dimnames = list(c("ra","rb"), c("u","v")))   
B2 <- matrix(22, 2, 3, dimnames = list(c("rc","rd"), c("v","w","x")))
out_r_dense <- combine_matrices_fast(list(A2, B2), bind = "rbind", fill = NA)
stopifnot(is.matrix(out_r_dense), identical(dim(out_r_dense), c(4L,4L)))

## --- Sparse matrices, cbind: duplicated colnames allowed ---
S1 <- Matrix::rsparsematrix(3, 2, 0.5)
dimnames(S1) <- list(c("r1","r2","r3"), c("sA","sA")) # duplicate colnames
S2 <- Matrix::rsparsematrix(2, 3, 0.5)
dimnames(S2) <- list(c("r2","r4"), c("sB","sA","sC")) # another "sA"
out_c_sparse <- combine_matrices_fast(list(S1, S2), bind = "cbind", fill = 0)
stopifnot(inherits(out_c_sparse, "sparseMatrix"), identical(dim(out_c_sparse), c(4L,5L)))

## --- Mixed inputs, nonzero fill forces dense ---
Mx <- matrix(1, 2, 2, dimnames = list(c("a","b"), c("x","y"))) 
Sy <- Matrix::rsparsematrix(2, 1, 1); dimnames(Sy) <- list(c("b","c"), "z")
out_mixed <- combine_matrices_fast(list(Mx, Sy), bind = "cbind", fill = NA, output_type = "auto")
stopifnot(is.matrix(out_mixed))  # dense result due to nonzero 'fill'

## --- Mixed inputs, 3 matrices, zero fill, sparse preserved ---
Td <- matrix(5, 1, 1, dimnames = list("a", "zz"))
out_mixed3 <- combine_matrices_fast(list(Mx, Sy, Td), bind = "cbind", fill = 0, output_type = "auto")
stopifnot(inherits(out_mixed3, "sparseMatrix"), identical(dim(out_mixed3), c(3L,4L)))

}
