% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/resegment_decisions.R
\name{decide_ReSegment_Operations_geometry}
\alias{decide_ReSegment_Operations_geometry}
\title{decide_ReSegment_Operations_geometry}
\usage{
decide_ReSegment_Operations_geometry(
  neighborhood_df,
  selfcellID_coln = "CellId",
  transNum_coln = "transcript_num",
  selfCellType_coln = "self_celltype",
  selfScore_coln = "score_under_self",
  neighborcellID_coln = "neighbor_CellId",
  neighborCellType_coln = "neighbor_celltype",
  neighborScore_coln = "score_under_neighbor",
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum = NULL,
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  transSpatLocs_coln = c("x", "y", "z"),
  cutoff_diffWB = 0.5
)
}
\arguments{
\item{neighborhood_df}{the data.frame containing neighborhood information for each query cells, expected to be output of neighborhood_for_resegment function.}

\item{selfcellID_coln}{the column name of cell_ID of query cell in neighborhood_df}

\item{transNum_coln}{the column name of transcript number of query cell in neighborhood_df}

\item{selfCellType_coln}{the column name of cell_type under query cell in neighborhood_df}

\item{selfScore_coln}{the column name of average transcript score under query cell in neighborhood_df}

\item{neighborcellID_coln}{the column name of cell_ID of neighbor cell in neighborhood_df}

\item{neighborCellType_coln}{the column name of cell_type under neighbor cell in neighborhood_df}

\item{neighborScore_coln}{the column name of average transcript score under neighbor cell in neighborhood_df}

\item{score_baseline}{a named vector of score baseline for all cell type listed in neighborhood_df such that per cell transcript score higher than the baseline is required to call a cell type of high enough confidence}

\item{lowerCutoff_transNum}{a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is}

\item{higherCutoff_transNum}{a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type.}

\item{transcript_df}{the data.frame with transcript_id, target/geneName, x, y and cell_id}

\item{cellID_coln}{the column name of cell_ID in transcript_df}

\item{transID_coln}{the column name of transcript_ID in transcript_df}

\item{transSpatLocs_coln}{the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript_df}

\item{cutoff_diffWB}{maximum percentage of white space change upon merging of query cell and neighbor cell for a valid merging event; default = 0.5 for 50\% cutoff}

\item{config_spatNW_transcript}{configuration list to create spatial network at transcript level}
}
\value{
a list
\enumerate{
\item{cells_to_discard, a vector of cell ID that should be discarded during resegmentation}
\item{cells_to_update, a named vector of cell ID whether the cell_ID in name would be replaced with cell_ID in value.}
\item{cells_to_keep, a vector of cell ID that should be kept as it is.}
\item{reseg_full_converter, a single named vector of cell ID to update the original cell ID, assign NA for cells_to_discard.}
}
}
\description{
Evaluate neighborhood information against score and transcript number cutoff to decide the resegmetation operations. Use geometry statistics to determine whether a merge event is allowed.
}
\details{
Evaluate neighborhood information against score and transcript number cutoff to decide the resegmetation operations.1) merge query to neighbor if consist cell type and fewer than average transcript number cutoff, higherCutoff_transNum; 2) keep query as new cell id if no consist neighbor cell type, but high self score and higher than minimal transcript number, lowerCutoff_transNum; 3) discard the rest of query cells that have no consistent neighbor cell type, fewer transcript number based on lowerCutoff_transNum, and/or low self score. Use network component analysis to resolve any conflict due to merging multiple query cells into one. In case of merging into neighbor cell, first calculate white space, i.e. the area difference between convex and concave hulls, respectively, for query cell, neighbor cell, and the corresponding merged cell; and then calculate the white space difference between the merged cell and two separate cells and normalize that value with respect to the concave area of query and neighbor cells, respectively; lastly, allow a valid merging when the normalized white space difference upon merging for both query and neighbor cells are smaller than the provided \code{cutoff_diffWB}.
Notice that geometry analysis on potential merge pairs is done at 2D and thus cells with z-overlaid have high chance of merging.
}
