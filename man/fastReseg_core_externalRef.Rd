% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrapper_FastReseg.R
\name{fastReseg_core_externalRef}
\alias{fastReseg_core_externalRef}
\title{fastReseg_core_externalRef}
\usage{
fastReseg_core_externalRef(
  refProfiles,
  transcript_df,
  transID_coln = "transcript_id",
  transGene_coln = "target",
  cellID_coln = "cell_ID",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL,
  flagModel_TransNum_cutoff = 50,
  flagCell_lm_cutoff = 5,
  svmClass_score_cutoff = -2,
  svm_args = list(kernel = "radial", scale = FALSE, gamma = 0.4),
  groupTranscripts_method = c("delaunay", "dbscan"),
  molecular_distance_cutoff = 2.7,
  cellular_distance_cutoff = NULL,
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum = NULL,
  leiden_args = list(objective_function = c("CPM", "modularity"), resolution_parameter
    = 1, beta = 0.01, n_iterations = 200),
  flagMerge_sharedLeiden_cutoff = 0.5,
  return_intermediates = TRUE,
  return_perCellData = TRUE,
  includeAllRefGenes = FALSE,
  ctrl_genes = NULL,
  celltype_method = "LogLikeRatio"
)
}
\arguments{
\item{refProfiles}{A matrix of cluster profiles, genes X clusters}

\item{transcript_df}{the data.frame for each transcript with columns for transcript_id, target or gene name, original cell_id, spatial coordinates.}

\item{transID_coln}{the column name of transcript_ID in \code{transcript_df}}

\item{transGene_coln}{the column name of target or gene name in \code{transcript_df}}

\item{cellID_coln}{the column name of cell_ID in \code{transcript_df}}

\item{spatLocs_colns}{column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript_df}}

\item{extracellular_cellID}{a vector of cell_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)}

\item{flagModel_TransNum_cutoff}{the cutoff of transcript number to do spatial modeling for identification of wrongly segmented cells (default = 50)}

\item{flagCell_lm_cutoff}{the cutoff of lm_-log10P to identify putative wrongly segemented cells with strong spatial dependency in transcript score profile}

\item{svmClass_score_cutoff}{the cutoff of transcript score to separate between high and low score transcripts in SVM (default = -2)}

\item{svm_args}{a list of arguments to pass to svm function for identifying low-score transcript groups in space, typically involve kernel, gamma, scale}

\item{groupTranscripts_method}{use either \code{delaunay} or \code{dbscan} method to group transcripts in space (default = 'delaunay')}

\item{molecular_distance_cutoff}{maximum molecule-to-molecule distance within connected transcript group, same unit as input spatial coordinate (default = 2.7 micron).
If set to NULL, the pipeline would first randomly choose no more than 2500 cells from up to 10 random picked ROIs with search radius to be 5 times of \code{cellular_distance_cutoff}, and then calculate the minimal molecular distance between picked cells. The pipeline would further use the 5 times of 90\% quantile of minimal molecular distance as \code{molecular_distance_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.}

\item{cellular_distance_cutoff}{maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate. Default = NULL to use the 2 times of average 2D cell diameter.}

\item{score_baseline}{a named vector of score baseline under each cell type listed in \code{refProfiles} such that  per cell transcript score higher than the baseline is required to call a cell type of high enough confidence}

\item{lowerCutoff_transNum}{a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is}

\item{higherCutoff_transNum}{a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type.}

\item{leiden_args}{a list of configuration to pass to reticulate and \code{igraph::cluster_leiden} function, including objective_function, resolution_parameter, beta, n_iterations.}

\item{flagMerge_sharedLeiden_cutoff}{minimal percentage of transcripts shared membership between query cell and neighbor cells in leiden clustering results for a valid merging event, default = 0.5 for 50\% cutoff}

\item{return_intermediates}{flag to return intermediate outputs, including data.frame for spatial modeling statistics of each cell}

\item{return_perCellData}{flag to return gene x cell count matrix and per cell DF with updated mean spatial coordinates and new cell type}

\item{includeAllRefGenes}{flag to include all genes in \code{refProfiles} in the returned \code{updated_perCellExprs} with missing genes of value 0 (default = FALSE)}

\item{ctrl_genes}{a vector of control genes that are present in input transcript data.frame but not present in \code{counts} or \code{refProfiles}; the \code{ctrl_genes} would be included in FastReseg analysis. (default = NULL)}

\item{celltype_method}{use either \code{LogLikeRatio} or \code{NegBinomial} method for quick cell typing and corresponding score_baseline calculation (default = LogLikeRatio)}
}
\value{
a list
\describe{
\item{modStats_ToFlagCells}{a data.frame for spatial modeling statistics of each cell, output of \code{score_cell_segmentation_error} function, return when \code{return_intermediates} = TRUE}
\item{groupDF_ToFlagTrans}{data.frame for the group assignment of transcripts within putative wrongly segmented cells, merged output of \code{flagTranscripts_SVM} and \code{groupTranscripts_Delaunay} or \code{groupTranscripts_dbscan} functions, return when \code{return_intermediates} = TRUE}
\item{neighborhoodDF_ToReseg}{a data.frame for neighborhood enviornment of low-score transcript groups, output of \code{neighborhood_for_resegment_spatstat} function, return when \code{return_intermediates} = TRUE}
\item{reseg_actions}{a list of 4 elements describing how the resegmenation would be performed on original \code{transcript_df} by the group assignment of transcripts listed in \code{groupDF_ToFlagTrans}, output of \code{decide_ReSegment_Operations_leidenCut} function, return when \code{return_intermediates} = TRUE}
\item{updated_transDF}{the updated transcript_df with \code{updated_cellID} and \code{updated_celltype} column based on reseg_full_converter}
\item{updated_perCellDT}{a per cell data.table with mean spatial coordinates, new cell type and resegmentation action after resegmentation, return when \code{return_perCellData} = TRUE}
\item{updated_perCellExprs}{a gene x cell count sparse matrix for updated transcript data.frame after resegmentation, return when \code{return_perCellData} = TRUE}
}
}
\description{
core wrapper for resegmentation pipeline using external reference profiles and cutoffs.
}
\details{
The pipeline would score each transcript based on the provided cell type-specific reference profiles, evaluate the goodness-of-fit of each transcript within original cell segment, identify the low-score transcript groups within cells that has strong spatial dependency in transcript score profile, evaluate the neighborhood environment of low-score transcript groups and perform resegmentation actions including triming to extracellular space, merging to neighbor cell or labeling as new cell.

To account for genes missing in \code{refProfiles} but present in input transcript data.frame, genes in \code{ctrl_genes} would be assigned with goodness-of-fit score equal to \code{svmClass_score_cutoff} for all cell types to minimize the impact of those genes on the identification of low-score transcript groups via SVM. To avoid significant interference from those \code{ctrl_genes}, it's recommended to have total counts of those genes below 1\% of total counts of all genes in each cell.
}
\examples{
data(example_refProfiles)
data(mini_transcriptDF)
data(example_baselineCT)
extracellular_cellID <- mini_transcriptDF[which(mini_transcriptDF$CellId ==0), 'cell_ID'] # cell_ID for extracellualr transcripts
score_baseline <- example_baselineCT[['span_score']][,"25\%"]
lowerCutoff_transNum  <- example_baselineCT[['span_transNum']][,"25\%"]
higherCutoff_transNum  <- example_baselineCT[['span_transNum']][,"50\%"]
final_res <- fastReseg_core_externalRef(refProfiles = example_refProfiles, 
                                        transcript_df = mini_transcriptDF,
                                        extracellular_cellID = extracellular_cellID, 
                                        molecular_distance_cutoff = 2.7,
                                        cellular_distance_cutoff = 25,
                                        score_baseline = score_baseline, 
                                        lowerCutoff_transNum = lowerCutoff_transNum, 
                                        higherCutoff_transNum= higherCutoff_transNum)
}
