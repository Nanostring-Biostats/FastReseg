% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/neighborhood_spatstat.R
\name{neighborhood_for_resegment_spatstat}
\alias{neighborhood_for_resegment_spatstat}
\title{neighborhood_for_resegment_spatstat}
\usage{
neighborhood_for_resegment_spatstat(
  chosen_cells = NULL,
  score_GeneMatrix,
  score_baseline = NULL,
  neighbor_distance_xy = NULL,
  distance_cutoff = 2.7,
  transcript_df,
  cellID_coln = "CellId",
  celltype_coln = "cell_type",
  transID_coln = "transcript_id",
  transGene_coln = "target",
  transSpatLocs_coln = c("x", "y", "z")
)
}
\arguments{
\item{chosen_cells}{the cell_ID of chosen cells need to be evaluate for re-segmentation}

\item{score_GeneMatrix}{the gene x cell-type matrix of log-like score of gene in each cell type}

\item{score_baseline}{a named vector of score baseline for all cell type listed in score_GeneMatrix}

\item{neighbor_distance_xy}{maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate. Default = NULL to use the 2 times of average 2D cell diameter.}

\item{distance_cutoff}{maximum molecule-to-molecule distance within connected transcript group, same unit as input spatial coordinate (default = 2.7 micron).
If set to NULL, the pipeline would first randomly choose no more than 2500 cells from up to 10 random picked ROIs with search radius to be 5 times of \code{neighbor_distance_xy}, and then calculate the minimal molecular distance between picked cells. The pipeline would further use the 10 times of 90\% quantile of minimal molecular distance as \code{distance_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.}

\item{transcript_df}{the data.frame with transcript_id, target/geneName, x, y and cell_id}

\item{cellID_coln}{the column name of cell_ID in transcript_df}

\item{celltype_coln}{the column name of cell_type in transcript_df}

\item{transID_coln}{the column name of transcript_ID in transcript_df}

\item{transGene_coln}{the column name of target or gene name in transcript_df}

\item{transSpatLocs_coln}{the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript_df}
}
\value{
a data.frame
#' \enumerate{
\item{CellId, original cell id of chosen cells}
\item{cell_type, original cell type of chosen cells}
\item{transcript_num, number of transcripts in chosen cells}
\item{self_celltype, cell type give maximum score for query cell only}
\item{score_under_self, score in query cell under its own maximum celltype}
\item{neighbor_CellId, cell id of neighbor cell whose cell type gives maximum score in query cell among all neighbors, not including query cell itself}
\item{neighbor_celltype, cell type that gives maximum score in query cell among all non-self neighbor cells}
\item{score_under_neighbor, score in query cell under neighbor_celltype}
}
}
\description{
find neighbor cells with transcripts that are direct neighbor of chosen_cell, check tLLRv2 score under neighbor cell type, return neighborhood information
}
\details{
Locate neighbor cells of each query cell firstly via cell-to-cell distance in 2D plane within neighbor_distance_xy, then via molecule-to-molecule 3D distance within distance_cutoff. If no neighbor cells found for query cell, use the cell id and cell type of query cell to fill in the columns for neighbor cells in returned data.frame
}
