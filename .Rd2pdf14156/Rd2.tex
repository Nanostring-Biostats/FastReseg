\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `FastReseg'}}
\par\bigskip{\large \today}
\end{center}
\inputencoding{utf8}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {FastReseg: An R Package for Detection and Correction of Cell Segmentation Error Based on Spatial Profile of Transcripts}}}{}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdfauthor = {Patrick Danaher; Lidan Wu}}}{}
\begin{description}
\raggedright{}
\item[Title]\AsIs{An R Package for Detection and Correction of Cell Segmentation Error Based on Spatial Profile of Transcripts}
\item[Version]\AsIs{1.0.0}
\item[Description]\AsIs{An R package for detection and correction of cell segmentation error based on spatial profile of transcripts}
\item[License]\AsIs{file LICENSE}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{true}
\item[Roxygen]\AsIs{list(markdown = TRUE)}
\item[RoxygenNote]\AsIs{7.3.1}
\item[Imports]\AsIs{lmtest,
MASS,
Matrix,
stats,
e1071,
igraph (>= 1.2.4.1),
spatstat.geom,
dbscan (>= 1.1-3),
dplyr,
concaveman,
data.table,
reshape2,
ggplot2,
fs,
stringr,
GiottoClass(>= 0.2.3),
geometry(>= 0.4.6.1),
parallel}
\item[Suggests]\AsIs{testthat (>= 3.0.0),
kableExtra,
knitr,
rmarkdown,
RTriangle (>= 1.6-0.10),
deldir (>= 1.0.6),
Giotto}
\item[Config/testthat/edition]\AsIs{3}
\item[VignetteBuilder]\AsIs{knitr}
\item[URL]\AsIs{}\url{https://nanostring-biostats.github.io/FastReseg/}\AsIs{}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{checkAndPrepInputs\_perFOV}{checkAndPrepInputs\_perFOV}{checkAndPrepInputs.Rul.perFOV}
%
\begin{Description}
supporting function for \code{fastReseg\_perFOV\_full\_process}, checks and preps inputs for full resegmentation pipeline on the provided \code{transcript\_df} and calculates distance cutoffs and set values for \code{config\_spatNW\_transcript} and \code{leiden\_config} if not provided.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
checkAndPrepInputs_perFOV(
  all_celltypes,
  all_genes,
  transcript_df,
  transID_coln = "UMI_transID",
  transGene_coln = "target",
  cellID_coln = "UMI_cellID",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL,
  flagModel_TransNum_cutoff = 50,
  molecular_distance_cutoff = 2.7,
  cellular_distance_cutoff = NULL,
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum = NULL,
  groupTranscripts_method = c("dbscan", "delaunay"),
  spatialMergeCheck_method = c("leidenCut", "geometryDiff"),
  cutoff_spatialMerge = 0.5,
  leiden_config = NULL,
  config_spatNW_transcript = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{all\_celltypes}] vector of all cell types consider in the analysis as listed in columns of \code{score\_GeneMatrix} in parent function

\item[\code{all\_genes}] vector of all genes consider in the analysis as listed in rows of \code{score\_GeneMatrix} in parent function

\item[\code{transcript\_df}] the data.frame for each transcript with columns for transcript\_id, target or gene name, original cell\_id, spatial coordinates.

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}

\item[\code{transGene\_coln}] the column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{extracellular\_cellID}] a vector of cell\_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)

\item[\code{flagModel\_TransNum\_cutoff}] the cutoff of transcript number to do spatial modeling for identification of wrongly segmented cells (default = 50)

\item[\code{molecular\_distance\_cutoff}] maximum molecule-to-molecule distance within connected transcript group, same unit as input spatial coordinate (default = 2.7 micron).
If set to NULL, the pipeline would first randomly choose no more than 2500 cells from up to 10 random picked ROIs with search radius to be 5 times of \code{cellular\_distance\_cutoff}, and then calculate the minimal molecular distance between picked cells. The pipeline would further use the 5 times of 90\% quantile of minimal molecular distance as \code{molecular\_distance\_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.

\item[\code{cellular\_distance\_cutoff}] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate. Default = NULL to use the 2 times of average 2D cell diameter.

\item[\code{score\_baseline}] a named vector of score baseline under each cell type listed in \code{score\_GeneMatrix} such that per cell transcript score higher than the baseline is required to call a cell type of high enough confidence

\item[\code{lowerCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is

\item[\code{higherCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type.

\item[\code{groupTranscripts\_method}] use either "dbscan" or "delaunay method" to group transcripts in space (default = "dbscan")

\item[\code{spatialMergeCheck\_method}] use either "leidenCut" (in 2D or 3D) or "geometryDiff" (in 2D only) method to determine whether a cell pair merging event is allowed in space (default = "leidenCut")

\item[\code{cutoff\_spatialMerge}] spatial constraint on a valid merging event between two source transcript groups, default = 0.5 for 50\% cutoff, set to 0 to skip spatial constraint evaluation for merging.
For \code{spatialMergeCheck\_method = "leidenCut"}, this is the minimal percentage of transcripts shared membership between query cell and neighbor cells in leiden clustering results for a valid merging event.
For \code{spatialMergeCheck\_method = "geometryDiff"}, this is the maximum percentage of white space change upon merging of query cell and neighbor cell for a valid merging event.

\item[\code{leiden\_config}] (leidenCut) a list of configuration to pass to reticulate and \code{igraph::cluster\_leiden} function, including objective\_function, resolution\_parameter, beta, n\_iterations.

\item[\code{config\_spatNW\_transcript}] configuration list to create spatial network at transcript level, see manual for \code{createSpatialDelaunayNW\_from\_spatLocs} for more details, set to NULL to use default config (default = NULL)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list
\begin{description}

\item[transcript\_df] transcript data.frame ready for downstream full resgmentation pipeline
\item[cellular\_distance\_cutoff] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate.
\item[molecular\_distance\_cutoff] maximum molecule-to-molecule distance within connected transcript group, same unit as input spatial coordinate
\item[config\_spatNW\_transcript] configuration list to create spatial network at transcript level
\item[leiden\_config] configuration list to do leiden clustering on spatial network at transcript level for merge event evaluation

\end{description}

\end{Value}
\inputencoding{utf8}
\HeaderA{checkTransFileInputsAndLoadFirst}{checkTransFileInputsAndLoadFirst}{checkTransFileInputsAndLoadFirst}
%
\begin{Description}
check input formats for transcript data.frame file list and load 1st fov
\end{Description}
%
\begin{Usage}
\begin{verbatim}
checkTransFileInputsAndLoadFirst(
  transcript_df = NULL,
  transDF_fileInfo = NULL,
  filepath_coln = "file_path",
  prefix_colns = c("slide", "fov"),
  fovOffset_colns = c("stage_X", "stage_Y"),
  pixel_size = 0.18,
  zstep_size = 0.8,
  transID_coln = NULL,
  transGene_coln = "target",
  cellID_coln = "CellId",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{transcript\_df}] the data.frame of transcript level information with unique CellId, set to NULL if read from the \code{transDF\_fileInfo}

\item[\code{transDF\_fileInfo}] a data.frame with each row for each individual file of per FOV transcript data.frame within which the coordinates and CellId are unique, columns include the file path of per FOV transcript data.frame file, annotation columns like slide and fov to be used as prefix when creating unique cell\_ID across entire data set; when NULL, use the provided \code{transcript\_df} directly

\item[\code{filepath\_coln}] the column name of each individual file of per FOV transcript data.frame in \code{transDF\_fileInfo}

\item[\code{prefix\_colns}] the column names of annotation in \code{transDF\_fileInfo}, to be added to the CellId as prefix when creating unique cell\_ID for entire data set; set to NULL if use the original \code{transID\_coln} or \code{cellID\_coln}

\item[\code{fovOffset\_colns}] the column name of coordinate offsets in 1st and 2nd dimension for each per FOV transcript data.frame in \code{transDF\_fileInfo}, unit in micron
Notice that some assays like SMI has XY axes swapped between stage and each FOV such that \code{fovOffset\_colns} should be c("stage\_Y", "stage\_X").

\item[\code{pixel\_size}] the micrometer size of image pixel listed in 1st and 2nd dimension of \code{spatLocs\_colns} of each \code{transcript\_df}

\item[\code{zstep\_size}] the micrometer size of z-step for the optional 3rd dimension of \code{spatLocs\_colns} of each \code{transcript\_df}

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}, default = NULL to use row index of transcript in each \code{transcript\_df}; when \code{prefix\_colns} != NULL, unique transcript\_id would be generated from \code{prefix\_colns} and \code{transID\_coln} in each \code{transcript\_df}

\item[\code{transGene\_coln}] the column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}; when \code{prefix\_colns} != NULL, unique cell\_ID would be generated from \code{prefix\_colns} and \code{cellID\_coln} in each \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{extracellular\_cellID}] a vector of cell\_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list contains transcript\_df for downstream process and extracellular transcript data.frame
' \begin{description}

\item[intraC] a data.frame for intracellular transcript, \code{UMI\_transID} and \code{UMI\_cellID} as column names for unique transcript\_id and cell\_id, \code{target} as column name for target gene name
\item[extraC] a data.frame for extracellular transcript, same structure as the \code{intraC} data.frame in returned list

\end{description}

\end{Value}
\inputencoding{utf8}
\HeaderA{checkTypeLengthValue}{checkTypeLengthValue}{checkTypeLengthValue}
%
\begin{Description}
checking whether a single value in config have correct data type, length and value range
\end{Description}
%
\begin{Usage}
\begin{verbatim}
checkTypeLengthValue(
  config,
  name,
  expect_type,
  expect_len = NULL,
  expect_range = c("equal", "larger", "smaller", "within"),
  expect_value = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{config}] the list storing config

\item[\code{name}] parameter name in config list

\item[\code{expect\_type}] expected data type for vector, e.g. c("numeric","integer") for integer values, "character", "logical", etc

\item[\code{expect\_len}] expected length, NULL for any length

\item[\code{expect\_range}] expect value range; use "larger","smaller", "equal", "within" for numeric values, but use only "within" for character

\item[\code{expect\_value}] a single numeric value or a character vector that would be used to check against with expect\_range, NULL for any value
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a message if config[\LinkA{name}{name}] does not satisfy the criteria
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
config <- list(pos_Integer = 1, neg_value = -0.2, flag = TRUE,
               length2character = c("a","b"))
# check if positive integer of any length
FastReseg:::checkTypeLengthValue(config, "pos_Integer",
                                 expect_type = c("numeric","integer"),
                                 expect_range = "larger", expect_value = 0)
# check if negative value of any length
FastReseg:::checkTypeLengthValue(config, "neg_value",
                                 expect_type = "numeric",
                                 expect_range = "smaller", expect_value = 0)
# check if logical value
FastReseg:::checkTypeLengthValue(config, "flag", expect_type = "logical")
# check if character has 2 elements within c("a","b")
FastReseg:::checkTypeLengthValue(config, "length2character",
                                 expect_type = "character", expect_len = 2,
                                 expect_range = "within", expect_value = c("a","b"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{check\_config\_leiden}{check\_config\_leiden}{check.Rul.config.Rul.leiden}
%
\begin{Description}
check config used for leiden clustering, assign default values if missing arguments
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_config_leiden(config)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{config}] a list of config would be used to create spatial network using delaunay method only via GiottoClass::createSpatialNetwork
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the corrected config list
\end{Value}
\inputencoding{utf8}
\HeaderA{check\_config\_spatialNW}{check\_config\_spatialNW}{check.Rul.config.Rul.spatialNW}
%
\begin{Description}
check config used to create spatial network, assign default values if missing arguments
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_config_spatialNW(config, spat_locs)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{config}] a list of config would be used to create spatial network using delaunay method only via GiottoClass::createSpatialNetwork

\item[\code{spat\_locs}] a data.frame with spatial location info
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the corrected config list
\end{Value}
\inputencoding{utf8}
\HeaderA{choose\_distance\_cutoff}{choose\_distance\_cutoff}{choose.Rul.distance.Rul.cutoff}
%
\begin{Description}
Choose appropriate cellular distance cutoff and molecular distance cutoff based on input transcript data.frame for downstream resegmentation; cellular distance cutoff is defined as the search radius of direct neighbor cell, while molecular distance cutoff is defined as the maximum distance between two neighbor transcripts from same source cells.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
choose_distance_cutoff(
  transcript_df,
  transID_coln = "UMI_transID",
  cellID_coln = "UMI_cellID",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL,
  run_molecularDist = TRUE,
  sampleSize_nROI = 10,
  sampleSize_cellNum = 2500,
  seed = 123
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{transcript\_df}] the data.frame for each transcript

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{extracellular\_cellID}] a vector of cell\_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)

\item[\code{run\_molecularDist}] flag to run molecular distant cutoff estimation, default = TRUE

\item[\code{sampleSize\_nROI}] number of ROIs randomly picked from data for molecular distance cutoff estimation

\item[\code{sampleSize\_cellNum}] maximum number of cells from the picked ROIs for molecular distance cutoff estimation

\item[\code{seed}] a random seed for sub-sampling cells from whole dataset for molecular distance cutoff estimation
\end{ldescription}
\end{Arguments}
%
\begin{Details}
\code{cellular\_distance\_cutoff} is defined as maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact. The function calculates average 2D cell diameter from input data.frame and use 2 times of the mean cell diameter as \code{cellular\_distance\_cutoff}. \code{molecular\_distance\_cutoff} is defined as maximum molecule-to-molecule distance within connected transcript groups belonging to same source cells. The function would first randomly choose \code{sampleSize\_cellNum} number of cells from \code{sampleSize\_nROI} number of randomly picked ROIs with search radius to be 5 times of \code{cellular\_distance\_cutoff}, and then calculate the minimal molecular distance between picked cells. The function would further use the 5 times of 90\% quantile of minimal molecular distance as \code{molecular\_distance\_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.
\end{Details}
%
\begin{Value}
a list
\begin{description}

\item[cellular\_distance\_cutoff] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate. 
\item[perCell\_coordDT] a data.table with cell in row, spatial XY coordinates of centroid and dimensions of bounding box in column
\item[molecular\_distance\_cutoff] maximum molecule-to-molecule distance within connected transcript group, same unit as input spatial coordinate; return if run\_molecularDist = TRUE
\item[distance\_profile] a named vector for the quantile profile of minimal molecular distance between transcripts belong to different cells at step size of 10\% quantile; return if run\_molecularDist = TRUE

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data(mini_transcriptDF)
# cell_ID for extracellualr transcripts
extracellular_cellID <- mini_transcriptDF[which(mini_transcriptDF$CellId ==0), 'cell_ID']
distCutoffs <- choose_distance_cutoff(mini_transcriptDF,
                                      extracellular_cellID = extracellular_cellID)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{compartment\_and\_add\_extra}{compartment\_and\_add\_extra}{compartment.Rul.and.Rul.add.Rul.extra}
%
\begin{Description}
add compartment label to the updated transcript data.frame returned by \code{fastReseg\_perFOV\_full\_process} and optional to combine it with transcripts got trimmed and originally extracellular transcripts
\end{Description}
%
\begin{Usage}
\begin{verbatim}
compartment_and_add_extra(
  updated_transDF,
  transcript_df,
  updatedCellID_coln = "updated_cellID",
  compartment_coln = "transComp",
  combine_extra = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{updated\_transDF}] transcript data.frame with transcript id and updated cell segmentation, one of the outputs  of \code{fastReseg\_perFOV\_full\_process}

\item[\code{transcript\_df}] list of 2 elements, \code{intraC} and \code{extraC} for intracellular and extracellular transcript data.frame, respectively; columns contain transcript id and original cell segmentation, output of \code{prepare\_perFOV\_transDF}

\item[\code{updatedCellID\_coln}] column name of updated cell ID in \code{updated\_transDF}, default = "updated\_cellID"

\item[\code{compartment\_coln}] column name for transcript compartment label, default = "transComp"

\item[\code{combine\_extra}] flag to combine original extracellular transcripts and trimmed transcripts back to the updated transcript data.frame, slow process if many transcript in each FOV file. (default = FALSE)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a transcript data.frame containing all original transcripts with updated cell segmentation and transcript compartments for \code{intraC}, \code{extraC} and \code{trimmed}
\end{Value}
\inputencoding{utf8}
\HeaderA{createSpatialDelaunayNW\_from\_spatLocs}{createSpatialDelaunayNW\_from\_spatLocs}{createSpatialDelaunayNW.Rul.from.Rul.spatLocs}
%
\begin{Description}
generate delaunay network based on provided config and spatial location using \code{GiottoClass} functions
\end{Description}
%
\begin{Usage}
\begin{verbatim}
createSpatialDelaunayNW_from_spatLocs(
  config_spatNW = list(name = "spatial_network", dimensions = "all", method = "Delaunay",
    minimum_k = 0, delaunay_method = "delaunayn_geometry", maximum_distance_delaunay =
    "auto", options = "Pp", Y = TRUE, j = TRUE, S = 0),
  spatLocs_df,
  ID_column = "cell_ID",
  spatLocs_column = c("sdimx", "sdimy", "sdimz")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{config\_spatNW}] configuration list

\item[\code{spatLocs\_df}] data.frame for spatial location of each entry for cell or transcript

\item[\code{ID\_column}] column name for entry ID in \code{spatLocs\_df}

\item[\code{spatLocs\_column}] column name for 1st, 2nd, optional 3rd dimension of spatial coordinates in \code{spatLocs\_df}
\end{ldescription}
\end{Arguments}
%
\begin{Details}
This function leverages \code{GiottoClass} package to create spatial networks from spatial coordinates. An example \code{config\_spatNW} list is shown below with possible options on controlling the spatial network generation. For more details, see the manual for \code{GiottoClass::createSpatialNetwork}.
\#' ' \begin{description}

\item[name] spatial network name; default = 'spatial\_network'
\item[dimensions] a vector for which spatial dimensions to use, default = 'all' to use all dimentions
\item[method] method name for creating a spatial network, default = 'Delaunay'
\item[minimum\_k] minimum number of nearest neighbors if maximum\_distance != NULL
\item[delaunay\_method] Delaunay method to use, choose from c("delaunayn\_geometry", "deldir", "RTriangle"), default = "delaunayn\_geometry"
\item[maximum\_distance\_delaunay] distance cuttoff for nearest neighbors to consider for Delaunay network, default = "auto"
\item[options] (geometry) String containing extra control options for the underlying Qhull command; see the Qhull documentation (../doc/qhull/html/qdelaun.html) for the available options; default = \code{Pp}, do not report precision problems)
\item[Y] (RTriangle) If TRUE prohibits the insertion of Steiner points on the mesh boundary
\item[j] (RTriangle) If TRUE jettisons vertices that are not part of the final triangulation from the output.
\item[S] (RTriangle) Specifies the maximum number of added Steiner points.

\end{description}

\end{Details}
%
\begin{Value}
delaunay\_network\_Obj, a spatial network object created by \code{GiottoClass} functions
\end{Value}
\inputencoding{utf8}
\HeaderA{decide\_ReSegment\_Operations}{decide\_ReSegment\_Operations}{decide.Rul.ReSegment.Rul.Operations}
%
\begin{Description}
Evaluate neighborhood information against score and transcript number cutoff to decide the resegmetation operations. Use either leiden clustering or geometry statistics to determine whether a merge event is allowed.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
decide_ReSegment_Operations(
  neighborhood_df,
  selfcellID_coln = "CellId",
  transNum_coln = "transcript_num",
  selfCellType_coln = "self_celltype",
  selfScore_coln = "score_under_self",
  neighborcellID_coln = "neighbor_CellId",
  neighborCellType_coln = "neighbor_celltype",
  neighborScore_coln = "score_under_neighbor",
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum = NULL,
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  transSpatLocs_coln = c("x", "y", "z"),
  spatialMergeCheck_method = c("leidenCut", "geometryDiff"),
  cutoff_spatialMerge = 0.5,
  leiden_config = list(objective_function = c("CPM", "modularity"), resolution_parameter
    = 1, beta = 0.01, n_iterations = 200),
  config_spatNW_transcript = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{neighborhood\_df}] the data.frame containing neighborhood information for each query cells, expected to be output of get\_neighborhood\_content function.

\item[\code{selfcellID\_coln}] the column name of cell\_ID of query cell in neighborhood\_df

\item[\code{transNum\_coln}] the column name of transcript number of query cell in neighborhood\_df

\item[\code{selfCellType\_coln}] the column name of cell\_type under query cell in neighborhood\_df

\item[\code{selfScore\_coln}] the column name of average transcript score under query cell in neighborhood\_df

\item[\code{neighborcellID\_coln}] the column name of cell\_ID of neighbor cell in neighborhood\_df

\item[\code{neighborCellType\_coln}] the column name of cell\_type under neighbor cell in neighborhood\_df

\item[\code{neighborScore\_coln}] the column name of average transcript score under neighbor cell in neighborhood\_df

\item[\code{score\_baseline}] a named vector of score baseline for all cell type listed in neighborhood\_df such that per cell transcript score higher than the baseline is required to call a cell type of high enough confidence

\item[\code{lowerCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is

\item[\code{higherCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type.

\item[\code{transcript\_df}] the data.frame with transcript\_id, target/geneName, x, y and cell\_id

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transSpatLocs\_coln}] the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df

\item[\code{spatialMergeCheck\_method}] use either "leidenCut" (in 2D or 3D) or "geometryDiff" (in 2D only) method to determine whether a cell pair merging event is allowed in space (default = "leidenCut")

\item[\code{cutoff\_spatialMerge}] spatial constraint on a valid merging event between two source transcript groups, default = 0.5 for 50\% cutoff, set to 0 to skip spatial constraint evaluation for merging.
For \code{spatialMergeCheck\_method = "leidenCut"}, this is the minimal percentage of transcripts shared membership between query cell and neighbor cells in leiden clustering results for a valid merging event.
For \code{spatialMergeCheck\_method = "geometryDiff"}, this is the maximum percentage of white space change upon merging of query cell and neighbor cell for a valid merging event.

\item[\code{leiden\_config}] (leidenCut) a list of configuration to pass to reticulate and \code{igraph::cluster\_leiden} function, including objective\_function, resolution\_parameter, beta, n\_iterations.

\item[\code{config\_spatNW\_transcript}] (leidenCut) configuration list to create spatial network at transcript level, see manual for \code{createSpatialDelaunayNW\_from\_spatLocs} for more details, set to NULL to use default config
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Evaluate neighborhood information against score and transcript number cutoff to decide the resegmetation operations like the following:
\begin{itemize}

\item{} merge query to neighbor if consist cell type and fewer than average transcript number cutoff, higherCutoff\_transNum;
\item{} keep query as new cell id if no consist neighbor cell type, but high self score and higher than minimal transcript number, lowerCutoff\_transNum;
\item{} discard the rest of query cells that have no consistent neighbor cell type, fewer transcript number based on lowerCutoff\_transNum, and/or low self score.
The function uses network component analysis to resolve any conflict due to merging multiple query cells into one.
When \code{cutoff\_spatialMerge > 0}, the function applies additional spatial constraint on a valid merging event of query cell into neighbor cell.
\item{} In case of \code{spatialMergeCheck\_method = "leidenCut"}, the function builds spatial network at transcript level, does leiden clustering  on the spatial network, and then decides whether the merge should be allowed based on the observed shared leiden membership of the two source transcript groups for a putative merging event; the provided \code{cutoff\_spatialMerge} gives the minimal values of shared leiden memberhsip for a valid merging event.
\item{} In case of \code{spatialMergeCheck\_method = "geometryDiff"}, the function would first calculate white space, i.e. the area difference between convex and concave hulls, respectively, for query cell, neighbor cell, and the corresponding merged cell; and then calculate the white space difference between the merged cell and two separate cells and normalize that value with respect to the concave area of query and neighbor cells, respectively; lastly, allow a valid merging when the normalized white space difference upon merging for both query and neighbor cells are smaller than the provided \code{cutoff\_spatialMerge}.

\end{itemize}

\end{Details}
%
\begin{Value}
a list
\begin{enumerate}

\item{} cells\_to\_discard, a vector of cell ID that should be discarded during resegmentation
\item{} cells\_to\_update, a named vector of cell ID where the cell\_ID in name would be replaced with cell\_ID in value.
\item{} cells\_to\_keep, a vector of cell ID that should be kept as it is.
\item{} reseg\_full\_converter, a single named vector of cell ID to update the original cell ID, assign NA for cells\_to\_discard.

\end{enumerate}

\end{Value}
\inputencoding{utf8}
\HeaderA{estimate\_MeanProfile}{estimate\_MeanProfile}{estimate.Rul.MeanProfile}
%
\begin{Description}
Given cell assignments (or posterior probabilities), estimate the mean profile of each cluster.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
estimate_MeanProfile(counts, clust, s, bg)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{counts}] Counts matrix, cells X genes.

\item[\code{clust}] Vector of cluster assignments, or a matrix of probabilities of cells (rows) belonging to clusters (columns).

\item[\code{s}] Vector of scaling factors for each cell, e.g. as defined by cell area.

\item[\code{bg}] Expected background
\end{ldescription}
\end{Arguments}
%
\begin{Details}
E step: estimate each cluster's mean profile (Ptolemy Estep function)

estimate each cluster's mean profile (Ptolemy Estep function)
\end{Details}
%
\begin{Value}
A matrix of cluster profiles, genes X clusters
\end{Value}
\inputencoding{utf8}
\HeaderA{example\_baselineCT}{Percentile profile for single cell distribution of transcript number and average tLLR score from example dataset for spatial transcriptional profiling of tissue}{example.Rul.baselineCT}
\keyword{datasets}{example\_baselineCT}
%
\begin{Description}
The example dataset is based on one run of SMI RNA readout for FFPE melanoma tissue samples. The single cell distribution was calculated for transcript number per cell and average transcript tLLR score per cell, and then grouped by the assigned cell types based on the original cell segmentation outcome to get the percentile profile for each cell type at 25\% increment step.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(example_baselineCT)
\end{verbatim}
\end{Usage}
%
\begin{Format}
An object of class \code{"list"} with 2 elements
\begin{description}

\item[span\_score] a matrix of average transcript tLLR score per cell for 22 distinct cell types in rows, percentile at (0\%, 25\%, 50\%, 75\%, 100\%) in columns
\item[span\_transNum] a matrix of transcript number per cell for 22 distinct cell types in rows, percentile at (0\%, 25\%, 50\%, 75\%, 100\%) in columns

\end{description}

\end{Format}
\inputencoding{utf8}
\HeaderA{example\_CellGeneExpr}{per cell gene expression matrix based on raw transcript data files generated by SMI}{example.Rul.CellGeneExpr}
\keyword{datasets}{example\_CellGeneExpr}
%
\begin{Description}
The example dataset is based on the cropped regions from two different FOVs of same SMI RNA readout run for FFPE melanoma tissue sample.
The corresponding raw transcript data files are
\begin{itemize}

\item{} \code{extdata/Run4104\_FOV001\_\_complete\_code\_cell\_target\_call\_coord.csv}
\item{} \code{extdata/Run4104\_FOV002\_\_complete\_code\_cell\_target\_call\_coord.csv}

\end{itemize}

Each raw transcript data files have 1 transcript per row with 25 different meta information in columns. Some important columns are
\begin{description}

\item[x] spatial coordinate of the transcript in x-axis of the given FOV, unit in pixel, 0.18um per pixel
\item[y] spatial coordinate of the transcript in y-axis of the given FOV, unit in pixel, 0.18um per pixel
\item[z] spatial coordinate of the transcript in z-axis of the given FOV, unit in z-step, 0.8um per z-step
\item[target] gene identity of given transcript
\item[CellId] the cell label assignment of given transcript within given FOV based on original cell segmentation

\end{description}

The per cell gene expression matrix is calculated from the raw transcript data files to include only the 960 true target genes without including control probes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(example_CellGeneExpr)
\end{verbatim}
\end{Usage}
%
\begin{Format}
An object of class \code{"matrix"} with 754 cells in row and 960 genes in columns
\end{Format}
%
\begin{SeeAlso}
\LinkA{example\_clust}{example.Rul.clust} for corresponding cell cluster assignment
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{example\_clust}{Cluster assignment for cells based on per cell gene expression profile and reference profiles in example data set}{example.Rul.clust}
\keyword{datasets}{example\_clust}
%
\begin{Description}
The example dataset is based on the cropped regions from two different FOVs of same SMI RNA readout run for FFPE melanoma tissue sample.
The corresponding raw transcript data files are
\begin{itemize}

\item{} \code{extdata/Run4104\_FOV001\_\_complete\_code\_cell\_target\_call\_coord.csv}
\item{} \code{extdata/Run4104\_FOV002\_\_complete\_code\_cell\_target\_call\_coord.csv}

\end{itemize}

Each raw transcript data files have 1 transcript per row with 25 different meta information in columns. Some important columns are
\begin{description}

\item[x] spatial coordinate of the transcript in x-axis of the given FOV, unit in pixel, 0.18um per pixel
\item[y] spatial coordinate of the transcript in y-axis of the given FOV, unit in pixel, 0.18um per pixel
\item[z] spatial coordinate of the transcript in z-axis of the given FOV, unit in z-step, 0.8um per z-step
\item[target] gene identity of given transcript
\item[CellId] the cell label assignment of given transcript within given FOV based on original cell segmentation

\end{description}

The cluster assignment for each cell is calculated based on the corresponding per cell gene expression profiles, \code{data/example\_CellGeneExpr.RData}, and reference profiles, \code{data/example\_refProfiles.RData}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(example_clust)
\end{verbatim}
\end{Usage}
%
\begin{Format}
An object of class \code{"character"} with 754 cells in same order as the cells in the row of \code{data/example\_CellGeneExpr.RData}.
\end{Format}
%
\begin{SeeAlso}
\LinkA{example\_CellGeneExpr}{example.Rul.CellGeneExpr} for corresponding cell x gene expression matrix, \LinkA{example\_refProfiles}{example.Rul.refProfiles} for the reference profiles used for cluster assignment
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{example\_refProfiles}{Data for cell type specific reference profiles}{example.Rul.refProfiles}
\keyword{datasets}{example\_refProfiles}
%
\begin{Description}
Semi-supervised cell typing is conducted on the example SMI RNA readout for FFPE melanoma tissue samples that contains 2 tissue sections with 3 FOVs per section. The resulting cell typing outcomes are then used to estimate the mean profile of each identified cell type/cluster using \code{"estimate\_MeanProfile"}. The corresponding average cell-type-specific profiles are then stored in \code{data("example\_refProfiles")} to be used as reference profiles.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(example_refProfiles)
\end{verbatim}
\end{Usage}
%
\begin{Format}
An object of class \code{"matrix"} with 960 genes in rows, 22 distinct cell types in columns.
\end{Format}
%
\begin{Examples}
\begin{ExampleCode}
data(example_refProfiles)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fastReseg\_flag\_all\_errors}{fastReseg\_flag\_all\_errors}{fastReseg.Rul.flag.Rul.all.Rul.errors}
%
\begin{Description}
Wrapper to process multiple files of one dataset for segmentation error detection in transcript level. The function reformats the individual transcript data.frame to have unique IDs and a global coordinate system and save into disk, then scores each cell for segmentation error and flags transcripts that have low goodness-of-fit to current cells.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fastReseg_flag_all_errors(
  counts,
  clust = NULL,
  refProfiles = NULL,
  transDF_fileInfo = NULL,
  filepath_coln = "file_path",
  prefix_colns = c("slide", "fov"),
  fovOffset_colns = c("stage_X", "stage_Y"),
  pixel_size = 0.18,
  zstep_size = 0.8,
  transcript_df = NULL,
  transID_coln = NULL,
  transGene_coln = "target",
  cellID_coln = "CellId",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL,
  flagModel_TransNum_cutoff = 50,
  flagCell_lrtest_cutoff = 5,
  svmClass_score_cutoff = -2,
  svm_args = list(kernel = "radial", scale = FALSE, gamma = 0.4),
  path_to_output = "reSeg_res",
  transDF_export_option = c(1, 2, 0),
  return_trimmed_perCell = FALSE,
  combine_extra = FALSE,
  ctrl_genes = NULL,
  seed_transError = NULL,
  percentCores = 0.75
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{counts}] Counts matrix for entire data set, cells X genes.

\item[\code{clust}] Vector of cluster assignments for each cell in \code{counts}, when NULL to automatically assign the cell cluster for each cell based on maximum transcript score of given the provided \code{refProfiles}

\item[\code{refProfiles}] A matrix of cluster profiles, genes X clusters, default = NULL to use external cluster assignments

\item[\code{transDF\_fileInfo}] a data.frame with each row for each individual file of per FOV transcript data.frame within which the coordinates and CellId are unique, columns include the file path of per FOV transcript data.frame file, annotation columns like slide and fov to be used as prefix when creating unique cell\_ID across entire data set; when NULL, use the provided \code{transcript\_df} directly

\item[\code{filepath\_coln}] the column name of each individual file of per FOV transcript data.frame in \code{transDF\_fileInfo}

\item[\code{prefix\_colns}] the column names of annotation in \code{transDF\_fileInfo}, to be added to the CellId as prefix when creating unique cell\_ID for entire data set; set to NULL if use the original \code{transID\_coln} or \code{cellID\_coln}

\item[\code{fovOffset\_colns}] the column name of coordinate offsets in 1st and 2nd dimension for each per FOV transcript data.frame in \code{transDF\_fileInfo}, unit in micron
Notice that some assays like SMI has XY axes swapped between stage and each FOV such that \code{fovOffset\_colns} should be c("stage\_Y", "stage\_X").

\item[\code{pixel\_size}] the micrometer size of image pixel listed in 1st and 2nd dimension of \code{spatLocs\_colns} of each \code{transcript\_df}

\item[\code{zstep\_size}] the micrometer size of z-step for the optional 3rd dimension of \code{spatLocs\_colns} of each \code{transcript\_df}

\item[\code{transcript\_df}] the data.frame of transcript level information with unique CellId, default = NULL to read from the \code{transDF\_fileInfo}

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}, default = NULL to use row index of transcript in each \code{transcript\_df}; when \code{prefix\_colns} != NULL, unique transcript\_id would be generated from \code{prefix\_colns} and \code{transID\_coln} in each \code{transcript\_df}

\item[\code{transGene\_coln}] the column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}; when \code{prefix\_colns} != NULL, unique cell\_ID would be generated from \code{prefix\_colns} and \code{cellID\_coln} in each \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{extracellular\_cellID}] a vector of cell\_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)

\item[\code{flagModel\_TransNum\_cutoff}] the cutoff of transcript number to do spatial modeling for identification of wrongly segmented cells (default = 50)

\item[\code{flagCell\_lrtest\_cutoff}] the cutoff of \code{lrtest\_nlog10P} to identify putative wrongly segmented cells with strong spatial dependency in transcript score profile

\item[\code{svmClass\_score\_cutoff}] the cutoff of transcript score to separate between high and low score transcripts in SVM (default = -2)

\item[\code{svm\_args}] a list of arguments to pass to svm function for identifying low-score transcript groups in space, typically involve kernel, gamma, scale

\item[\code{path\_to\_output}] the file path to output folder; directory would be created by function if not exists; \code{flagged\_transDF}, the reformatted transcript data.frame with transcripts of low goodness-of-fit flagged by\code{ SVM\_class = 0}, and \code{modStats\_ToFlagCells}, the per cell evaluation output of segmentation error, and \code{classDF\_ToFlagTrans}, the class assignment of transcripts within each flagged cells are saved as individual csv files for each FOV, respectively.

\item[\code{transDF\_export\_option}] option on how to export updated transcript\_df, 0 for no export, 1 for write to \code{path\_to\_output} in disk as csv for each FOV, 2 for return to function as list (default = 1)

\item[\code{return\_trimmed\_perCell}] flag to return a gene x cell count sparse matrix where all putative contaminating transcripts are trimmed (default = FALSE)

\item[\code{combine\_extra}] flag to combine original extracellular transcripts back to the flagged transcript data.frame. (default = FALSE)

\item[\code{ctrl\_genes}] a vector of control genes that are present in input transcript data.frame but not present in \code{counts} or \code{refProfiles}; the \code{ctrl\_genes} would be included in FastReseg analysis. (default = NULL)

\item[\code{seed\_transError}] seed for transcript error detection step, default = NULL to skip the seed

\item[\code{percentCores}] percent of cores to use for parallel processing (0-1] (default = 0.75)
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The function would first estimate mean profile for each cell cluster based on the provided cell x gene count matrix and cluster assignment for entire data set.
And then, the function would use the estimated cluster-specific profile as reference profiles when not provided.
For each transcript data.frame, the function would score each transcript based on the provided cell type-specific reference profiles, evaluate the goodness-of-fit of each transcript within original cell segment, and identify the low-score transcript groups within cells that has strong spatial dependency in transcript score profile.
When \code{transDF\_export\_option =1}, the function would save the each per FOV output as individual file in \code{path\_to\_output} directory; \code{flagged\_transDF}, \code{modStats\_ToFlagCells} and \code{classDF\_ToFlagTrans} would be saved as csv file, respectively.
\begin{description}

\item[flagged\_transDF] a transcript data.frame for each FOV, with columns for unique IDs of transcripts \code{UMI\_transID} and cells \code{UMI\_cellID}, for global coordinate system \code{x}, \code{y}, \code{z}, and for the goodness-of-fit in original cell segment \code{SMI\_class}; the original per FOV cell ID and pixel/index-based coordinates systems are saved under columns, \code{CellId}, \code{pixel\_x}, \code{pixel\_y}, \code{idx\_z}
\item[modStats\_ToFlagCells] a data.frame for spatial modeling statistics of each cell, output of \code{score\_cell\_segmentation\_error} function
\item[classDF\_ToFlagTrans] data.frame for the class assignment of transcripts within putative wrongly segmented cells, output of \code{flag\_bad\_transcripts} functions

\end{description}


To account for genes missing in \code{refProfiles} but present in input transcript data.frame, genes in \code{ctrl\_genes} would be assigned with goodness-of-fit score equal to \code{svmClass\_score\_cutoff} for all cell types to minimize the impact of those genes on the identification of low-score transcript groups via SVM. To avoid significant interference from those \code{ctrl\_genes}, it's recommended to have total counts of those genes below 1\% of total counts of all genes in each cell.
\end{Details}
%
\begin{Value}
a list
\begin{description}

\item[refProfiles] a genes * clusters matrix of cluster-specific reference profiles used in resegmenation pipeline
\item[baselineData] a list of two matrices in cluster * percentile format for the cluster-specific percentile distribution of per cell value; \code{span\_score} is for the average per molecule transcript tLLR score of each cell, \code{span\_transNum} is for the transcript number of each cell.
\item[ctrl\_genes] a vector of control genes whose transcript scores are set to fixed value for all cell types, return when \code{ctrl\_genes} is not NULL.
\item[combined\_modStats\_ToFlagCells] a data.frame for spatial modeling statistics of each cell for all cells in the data set, output of \code{score\_cell\_segmentation\_error} function
\item[combined\_flaggedCells] a list with each element to be a vector of \code{UMI\_cellID} for cells flagged for potential cell segmentation errors within each FOV
\item[trimmed\_perCellExprs] a gene x cell count sparse matrix where all putative contaminating transcripts are trimmed, return when \code{return\_trimmed\_perCell} = TRUE
\item[flagged\_transDF\_list] a list of per-FOV transcript data.frame with flagging information in \code{SVM\_class} column, return when \code{transDF\_export\_option = 2}

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data("mini_transcriptDF")
data("ori_RawExprs")
data("example_refProfiles")
data("example_baselineCT")
# cell_ID for extracellualr transcripts
extracellular_cellID <- mini_transcriptDF[which(mini_transcriptDF$CellId ==0), 'cell_ID'] 

# case #'1: provide `transcript_df` directly,
# do auto cluster assignment of each cell based on gene expression matrix, 
# `counts`, and cluster-specific reference profiles, `refProfiles`
res1 <- fastReseg_flag_all_errors(counts = ori_RawExprs,
                                  clust = NULL,
                                  refProfiles = example_refProfiles,
                                  pixel_size = 1,
                                  zstep_size = 1,
                                  transcript_df = mini_transcriptDF,
                                  transID_coln = "UMI_transID",
                                  transGene_coln = "target",
                                  cellID_coln = "UMI_cellID",
                                  spatLocs_colns = c("x","y","z"),
                                  extracellular_cellID = extracellular_cellID,
                                  path_to_output = "res1f_directDF")

# case #'2: provide file paths to per FOV transcript data files and specify 
# the spatial offset for each FOV,
# do auto-calculation of cluster-specific reference profiles from gene 
# expression matrix, `counts`, and cluster assignment of each cell, `clust`.
data("example_CellGeneExpr")
data("example_clust")

# the example individual transcript files are stored under `data` directory of this package
# update your path accordingly
# Notice that some assays like SMI has XY axes swapped between stage and each FOV;
# coordinates for each FOV should have units in micron
dataDir <- system.file("extdata", package = "FastReseg")
fileInfo_DF <- data.frame(
  file_path = fs::path(dataDir,
                       c("Run4104_FOV001__complete_code_cell_target_call_coord.csv",
                         "Run4104_FOV002__complete_code_cell_target_call_coord.csv")),
  slide = c(1, 1),
  fov = c(1,2),
  stage_X = 1000*c(5.13, -2.701),
  stage_Y = 1000*c(-0.452, 0.081))

res2 <- fastReseg_flag_all_errors(counts = example_CellGeneExpr,
                                  clust = example_clust,
                                  refProfiles = NULL,
                                  transDF_fileInfo =fileInfo_DF,
                                  filepath_coln = 'file_path',
                                  prefix_colns = c('slide','fov'),
                                  
                                  # match XY axes between stage and each FOV
                                  fovOffset_colns = c('stage_Y','stage_X'), 
                                  # 0.18 micron per pixel in transcript data
                                  pixel_size = 0.18, 
                                  # 0.8 micron per z step in transcript data
                                  zstep_size = 0.8, 
                                  
                                  transcript_df = NULL,
                                  
                                  # row index as transcript_id
                                  transID_coln = NULL, 
                                  
                                  transGene_coln = "target",
                                  cellID_coln = "CellId",
                                  spatLocs_colns = c("x","y","z"),
                                  
                                  # CellId = 0 means extracelluar transcripts in raw data
                                  extracellular_cellID = c(0), 
                                  
                                  path_to_output = "res2f_multiFiles")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fastReseg\_full\_pipeline}{fastReseg\_full\_pipeline}{fastReseg.Rul.full.Rul.pipeline}
%
\begin{Description}
wrapper for full resegmentation pipeline using internal reference profiles and cutoffs. This function first estimates proper reference profiles and cutoffs from the provided data and then use \code{fastReseg\_perFOV\_full\_process} function to process each transcript data.frame.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fastReseg_full_pipeline(
  counts,
  clust = NULL,
  refProfiles = NULL,
  transDF_fileInfo = NULL,
  filepath_coln = "file_path",
  prefix_colns = c("slide", "fov"),
  fovOffset_colns = c("stage_X", "stage_Y"),
  pixel_size = 0.18,
  zstep_size = 0.8,
  transcript_df = NULL,
  transID_coln = NULL,
  transGene_coln = "target",
  cellID_coln = "CellId",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL,
  flagModel_TransNum_cutoff = 50,
  flagCell_lrtest_cutoff = 5,
  svmClass_score_cutoff = -2,
  svm_args = list(kernel = "radial", scale = FALSE, gamma = 0.4),
  molecular_distance_cutoff = 2.7,
  cellular_distance_cutoff = NULL,
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum = NULL,
  imputeFlag_missingCTs = TRUE,
  groupTranscripts_method = c("dbscan", "delaunay"),
  spatialMergeCheck_method = c("leidenCut", "geometryDiff"),
  cutoff_spatialMerge = 0.5,
  leiden_config = list(objective_function = "CPM", resolution_parameter = 1, beta = 0.01,
    n_iterations = 200),
  config_spatNW_transcript = NULL,
  path_to_output = "reSeg_res",
  transDF_export_option = c(1, 2, 0),
  save_intermediates = TRUE,
  return_perCellData = TRUE,
  combine_extra = FALSE,
  ctrl_genes = NULL,
  seed_process = NULL,
  percentCores = 0.75
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{counts}] Counts matrix for entire dataset, cells X genes.

\item[\code{clust}] Vector of cluster assignments for each cell in \code{counts}, when NULL to automatically assign the cell cluster for each cell based on maximum transcript score of given the provided \code{refProfiles}

\item[\code{refProfiles}] A matrix of cluster profiles, genes X clusters, default = NULL to use external cluster assignments

\item[\code{transDF\_fileInfo}] a data.frame with each row for each individual file of per FOV transcript data.frame within which the coordinates and CellId are unique, columns include the file path of per FOV transcript data.frame file, annotation columns like slide and fov to be used as prefix when creating unique cell\_ID across entire dataset; when NULL, use the provided \code{transcript\_df} directly

\item[\code{filepath\_coln}] the column name of each individual file of per FOV transcript data.frame in \code{transDF\_fileInfo}

\item[\code{prefix\_colns}] the column names of annotation in \code{transDF\_fileInfo}, to be added to the CellId as prefix when creating unique cell\_ID for entire dataset; set to NULL if use the original \code{transID\_coln} or \code{cellID\_coln}

\item[\code{fovOffset\_colns}] the column name of coordinate offsets in 1st and 2nd dimension for each per FOV transcript data.frame in \code{transDF\_fileInfo}, unit in micron
Notice that some assays like SMI has XY axes swapped between stage and each FOV such that \code{fovOffset\_colns} should be c("stage\_Y", "stage\_X").

\item[\code{pixel\_size}] the micrometer size of image pixel listed in 1st and 2nd dimension of \code{spatLocs\_colns} of each \code{transcript\_df}

\item[\code{zstep\_size}] the micrometer size of z-step for the optional 3rd dimension of \code{spatLocs\_colns} of each \code{transcript\_df}

\item[\code{transcript\_df}] the data.frame of transcript level information with unique CellId, default = NULL to read from the \code{transDF\_fileInfo}

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}, default = NULL to use row index of transcript in each \code{transcript\_df}; when \code{prefix\_colns} != NULL, unique transcript\_id would be generated from \code{prefix\_colns} and \code{transID\_coln} in each \code{transcript\_df}

\item[\code{transGene\_coln}] the column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}; when \code{prefix\_colns} != NULL, unique cell\_ID would be generated from \code{prefix\_colns} and \code{cellID\_coln} in each \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{extracellular\_cellID}] a vector of cell\_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)

\item[\code{flagModel\_TransNum\_cutoff}] the cutoff of transcript number to do spatial modeling for identification of wrongly segmented cells (default = 50)

\item[\code{flagCell\_lrtest\_cutoff}] the cutoff of lrtest\_nlog10P to identify putative wrongly segemented cells with strong spatial dependency in transcript score profile

\item[\code{svmClass\_score\_cutoff}] the cutoff of transcript score to separate between high and low score transcripts in SVM (default = -2)

\item[\code{svm\_args}] a list of arguments to pass to svm function for identifying low-score transcript groups in space, typically involve kernel, gamma, scale

\item[\code{molecular\_distance\_cutoff}] maximum molecule-to-molecule distance within connected transcript group, unit in micron (default = 2.7 micron).
If set to NULL, the pipeline would first randomly choose no more than 2500 cells from up to 10 random picked ROIs with search radius to be 5 times of \code{cellular\_distance\_cutoff}, and then calculate the minimal molecular distance between picked cells. The pipeline would further use the 5 times of 90\% quantile of minimal molecular distance as \code{molecular\_distance\_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.

\item[\code{cellular\_distance\_cutoff}] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, unit in micron. Default = NULL to use the 2 times of average 2D cell diameter.

\item[\code{score\_baseline}] a named vector of score baseline under each cell type listed in \code{refProfiles} such that  per cell transcript score higher than the baseline is required to call a cell type of high enough confidence; default = NULL to calculate from \code{counts} and \code{refProfiles}

\item[\code{lowerCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is; default = NULL to calculate from \code{counts} and \code{refProfiles}

\item[\code{higherCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type; default = NULL to calculate from \code{counts} and \code{refProfiles}

\item[\code{imputeFlag\_missingCTs}] flag to impute \code{score\_baseline}, \code{lowerCutoff\_transNum},\code{higherCutoff\_transNum} for cell types present in \code{refProfiles} but missing in the provided transcript data files or the provided baseline and cutoffs; when TRUE, the median values of existing cell types would be used as the values for missing cell types.

\item[\code{groupTranscripts\_method}] use either "dbscan" or "delaunay method" to group transcripts in space (default = "dbscan")

\item[\code{spatialMergeCheck\_method}] use either "leidenCut" (in 2D or 3D) or "geometryDiff" (in 2D only) method to determine whether a cell pair merging event is allowed in space (default = "leidenCut")

\item[\code{cutoff\_spatialMerge}] spatial constraint on a valid merging event between two source transcript groups, default = 0.5 for 50\% cutoff, set to 0 to skip spatial constraint evaluation for merging.
For \code{spatialMergeCheck\_method = "leidenCut"}, this is the minimal percentage of transcripts shared membership between query cell and neighbor cells in leiden clustering results for a valid merging event.
For \code{spatialMergeCheck\_method = "geometryDiff"}, this is the maximum percentage of white space change upon merging of query cell and neighbor cell for a valid merging event.

\item[\code{leiden\_config}] (leidenCut) a list of configuration to pass to reticulate and \code{igraph::cluster\_leiden} function, including objective\_function, resolution\_parameter, beta, n\_iterations.

\item[\code{config\_spatNW\_transcript}] configuration list to create spatial network at transcript level, see manual for \code{createSpatialDelaunayNW\_from\_spatLocs} for more details, set to NULL to use default config (default = NULL)

\item[\code{path\_to\_output}] the file path to output folder where the resegmentation data is saved; directory would be created by function if not exists; transcript data.frame \code{updated\_transDF} is saved as individual csv files for each FOV, while cell data of all FOVs, \code{updated\_perCellDT} and \code{updated\_perCellExprs}, are combined to save as \code{.rds} object.

\item[\code{transDF\_export\_option}] option on how to export updated transcript\_df, 0 for no export, 1 for write to \code{path\_to\_output} in disk as csv for each FOV, 2 for return to function as list (default = 1)

\item[\code{save\_intermediates}] flag to save intermediate outputs into output folder, including data.frame for spatial modeling statistics of each cell,

\item[\code{return\_perCellData}] flag to return for gene x cell count matrix and per cell DF with updated mean spatial coordinates and new cell type, also export to output folder in disk when \code{transDF\_export\_option = 1}.

\item[\code{combine\_extra}] flag to combine original extracellular transcripts and trimmed transcripts back to the updated transcript data.frame, slow process if many transcript in each FOV file. (default = FALSE)

\item[\code{ctrl\_genes}] a vector of control genes that are present in input transcript data.frame but not in \code{refProfiles} and expect no cell type dependency, e.g. negative control probes; the \code{ctrl\_genes} would be included in FastReseg analysis. (default = NULL)

\item[\code{seed\_process}] seed for per FOV processing, used in transcript error detection and correction steps, default = NULL to skip the seed

\item[\code{percentCores}] percent of cores to use for parallel processing (0-1] (default = 0.75)
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The pipeline would first estimate mean profile for each cell cluster based on the provided cell x gene count matrix and cluster assignment for entire data set.
And then, the pipeline would use the estimated cluster-specific profile as reference profiles and calculate suitable cutoff for distance search, transcript number and score in first provided per FOV transcript data frame when those cutoffs are not provided.
When transcript data.frame is provided as multiple file paths in \code{transDF\_fileInfo} data.frame, the pipeline would further perform resegmentation on individual transcript data.frame using the baseline and cutoff defined globally.
For each transcript data.frame, the pipeline would score each transcript based on the provided cell type-specific reference profiles, evaluate the goodness-of-fit of each transcript within original cell segment,
identify the low-score transcript groups within cells that has strong spatial dependency in transcript score profile,
evaluate the neighborhood environment of low-score transcript groups and perform resegmentation actions including triming to extracellular space, merging to neighbor cell or labeling as new cell.

To account for genes missing in \code{refProfiles} but present in input transcript data.frame, genes in \code{ctrl\_genes} would be assigned with goodness-of-fit score equal to \code{svmClass\_score\_cutoff} for all cell types to minimize the impact of those genes on the identification of low-score transcript groups via SVM. To avoid significant interference from those \code{ctrl\_genes}, it's recommended to have total counts of those genes below 1\% of total counts of all genes in each cell.

The pipeline would save the each per FOV output as individual file in \code{path\_to\_output} directory; \code{updated\_transDF} would be saved as csv file.
When \code{save\_intermediates} = TRUE, all intermediate files and resegmenation outputs of each FOV would be saved as single \code{.rds} object which is a list containing the following elements:
\begin{description}

\item[modStats\_ToFlagCells] a data.frame for spatial modeling statistics of each cell, output of \code{score\_cell\_segmentation\_error} function, save when \code{save\_intermediates} = TRUE
\item[groupDF\_ToFlagTrans] data.frame for the group assignment of transcripts within putative wrongly segmented cells, merged output of \code{flag\_bad\_transcripts} and \code{groupTranscripts\_Delaunay} or \code{groupTranscripts\_dbscan} functions, save when \code{save\_intermediates} = TRUE
\item[neighborhoodDF\_ToReseg] a data.frame for neighborhood environment of low-score transcript groups, output of \code{get\_neighborhood\_content} function, save when \code{save\_intermediates} = TRUE
\item[reseg\_actions] a list of 4 elements describing how the resegmenation would be performed on original \code{transcript\_df} by the group assignment of transcripts listed in \code{groupDF\_ToFlagTrans}, output of \code{decide\_ReSegment\_Operations} function, save when \code{save\_intermediates} = TRUE
\item[updated\_transDF] the updated transcript\_df with \code{updated\_cellID} and \code{updated\_celltype} column based on reseg\_full\_converter, write to disk when \code{transDF\_export\_option =1}
\item[updated\_perCellDT] a per cell data.table with mean spatial coordinates, new cell type and resegmentation action after resegmentation, return when \code{return\_perCellData} = TRUE
\item[updated\_perCellExprs] a gene x cell count sparse matrix for updated transcript data.frame after resegmentation, return when \code{return\_perCellData} = TRUE

\end{description}

The pipeline would also combine per cell data for all FOVs and return the combined data when \code{return\_perCellData} = TRUE; \code{updated\_perCellDT} and \code{updated\_perCellExprs} would also be saved in a list as single \code{.rds} object in \code{path\_to\_output} directory when  \code{transDF\_export\_option = 1}.
\begin{description}

\item[updated\_perCellDT] a per cell data.table with mean spatial coordinates, new cell type and resegmentation action after resegmentation, return when \code{return\_perCellData} = TRUE
\item[updated\_perCellExprs] a gene x cell count sparse matrix for updated transcript data.frame after resegmentation, return when \code{return\_perCellData} = TRUE

\end{description}

\end{Details}
%
\begin{Value}
a list
\begin{description}

\item[refProfiles] a genes X clusters matrix of cluster-specific reference profiles used in resegmenation pipeline
\item[baselineData] a list of two matrice in cluster X percentile format for the cluster-specific percentile distribution of per cell value; \code{span\_score} is for the average per molecule transcript tLLR score of each cell, \code{span\_transNum} is for the transcript number of each cell.
\item[cutoffs\_list] a list of cutoffs used in resegmentation pipeline, including, \code{score\_baseline}, \code{lowerCutoff\_transNum}, \code{higherCutoff\_transNum}, \code{cellular\_distance\_cutoff}, \code{molecular\_distance\_cutoff}
\item[ctrl\_genes] a vector of control genes whose transcript scores are set to fixed value for all cell types, return when \code{ctrl\_genes} is not NULL.
\item[updated\_perCellDT] a per cell data.table with mean spatial coordinates, new cell type and resegmentation action after resegmentation, return when \code{return\_perCellData} = TRUE
\item[updated\_perCellExprs] a gene x cell count sparse matrix for updated transcript data.frame after resegmentation, return when \code{return\_perCellData} = TRUE
\item[reseg\_actions] a list of 4 elements describing how the resegmenation would be performed on original \code{transcript\_df} by the group assignment of transcripts listed in \code{groupDF\_ToFlagTrans}, output of \code{decide\_ReSegment\_Operations} function, return when \code{save\_intermediates} = TRUE
\item[updated\_transDF\_list] a list of per-FOV transcript data.frame with updated cell segmenation in \code{updated\_cellID} and \code{updated\_celltype} columns, return when \code{transDF\_export\_option = 2}

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# get example based on example dataset
data("mini_transcriptDF")
data("ori_RawExprs")
data("example_refProfiles")
data("example_baselineCT")
# cell_ID for extracellualr transcripts
extracellular_cellID <- mini_transcriptDF[which(mini_transcriptDF$CellId ==0), 'cell_ID'] 

# case #'1: provide `transcript_df` directly,
# do auto-calculation of distance cutoff from data while using the provided 
# cutoffs for score and transcript numbers.
res1 <- fastReseg_full_pipeline(counts = ori_RawExprs,
                                clust = NULL,
                                refProfiles = example_refProfiles,
                                pixel_size = 1,
                                zstep_size = 1,
                                transcript_df = mini_transcriptDF,
                                transID_coln = "UMI_transID",
                                transGene_coln = "target",
                                cellID_coln = "UMI_cellID",
                                spatLocs_colns = c("x","y","z"),
                                extracellular_cellID = extracellular_cellID,
                                molecular_distance_cutoff = NULL,
                                cellular_distance_cutoff = NULL,
                                score_baseline = example_baselineCT[['score_baseline']],
                                lowerCutoff_transNum = example_baselineCT[['lowerCutoff_transNum']],
                                higherCutoff_transNum= example_baselineCT[['higherCutoff_transNum']],
                                imputeFlag_missingCTs = TRUE,
                                path_to_output = "res1_directDF")

# case #'2: provide file paths to per FOV transcript data files and specify 
# the spatial offset for each FOV,
# do auto-calculation of score and transcript number cutoffs from gene 
# expression matrix, `counts`, and cluster assignment of each cell, `clust`,
# do auto-calculation of distance cutoff from the 1st per FOV transcript data.
data("example_CellGeneExpr")
data("example_clust")

# the example individual transcript files are stored under `data` directory of this package
# update your path accordingly
# Notice that some assays like SMI has XY axes swapped between stage and each FOV;
# coordinates for each FOV should have units in micron
dataDir <- system.file("extdata", package = "FastReseg")
fileInfo_DF <- data.frame(
  file_path = fs::path(dataDir,  
                       c("Run4104_FOV001__complete_code_cell_target_call_coord.csv",
                         "Run4104_FOV002__complete_code_cell_target_call_coord.csv")),
  slide = c(1, 1),
  fov = c(1,2),
  stage_X = 1000*c(5.13, -2.701),
  stage_Y = 1000*c(-0.452, 0.081))

res2 <- fastReseg_full_pipeline(counts = example_CellGeneExpr,
                                clust = example_clust,
                                refProfiles = NULL,
                                transDF_fileInfo =fileInfo_DF,
                                filepath_coln = 'file_path',
                                prefix_colns = c('slide','fov'),
                                
                                # match XY axes between stage and each FOV
                                fovOffset_colns = c('stage_Y','stage_X'), 
                                # 0.18 micron per pixel in transcript data
                                pixel_size = 0.18, 
                                # 0.8 micron per z step in transcript data
                                zstep_size = 0.8, 
                                
                                transcript_df = NULL,
                                
                                # row index as transcript_id
                                transID_coln = NULL, 
                                
                                transGene_coln = "target",
                                cellID_coln = "CellId",
                                spatLocs_colns = c("x","y","z"),
                                
                                # CellId = 0 means extracelluar transcripts in raw data
                                extracellular_cellID = c(0), 
                                
                                molecular_distance_cutoff = NULL,
                                cellular_distance_cutoff = NULL,
                                score_baseline = NULL,
                                lowerCutoff_transNum = NULL,
                                higherCutoff_transNum= NULL,
                                imputeFlag_missingCTs = TRUE,
                                path_to_output = "res2_multiFiles")

# case #'3: provide file paths to per FOV transcript data files and specify 
# the spatial offset for each FOV,
# do auto-calculation of score and transcript number cutoffs from gene 
# expression matrix, `counts`, and cluster-specific reference profiles, `refProfiles`,
# use the provided distance cutoff for `molecular_distance_cutoff` but 
# calculate the `cellular_distance_cutoff`
res3 <- fastReseg_full_pipeline(counts = example_CellGeneExpr,
                                clust = NULL,
                                refProfiles = example_refProfiles,
                                transDF_fileInfo =fileInfo_DF,
                                filepath_coln = 'file_path',
                                prefix_colns = c('slide','fov'),
                                fovOffset_colns = c('stage_Y','stage_X'), 
                                pixel_size = 0.18, 
                                zstep_size = 0.8, 
                                transcript_df = NULL,
                                transID_coln = NULL, 
                                transGene_coln = "target",
                                cellID_coln = "CellId",
                                spatLocs_colns = c("x","y","z"),
                                extracellular_cellID = c(0), 
                                molecular_distance_cutoff = 2.7,
                                cellular_distance_cutoff = NULL,
                                score_baseline = NULL,
                                lowerCutoff_transNum = NULL,
                                higherCutoff_transNum= NULL,
                                imputeFlag_missingCTs = TRUE,
                                path_to_output = "res3_multiFiles")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fastReseg\_perFOV\_full\_process}{fastReseg\_perFOV\_full\_process}{fastReseg.Rul.perFOV.Rul.full.Rul.process}
%
\begin{Description}
core wrapper for resegmentation pipeline using transcript score matrix derived from external reference profiles and preset cutoffs
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fastReseg_perFOV_full_process(
  score_GeneMatrix,
  transcript_df,
  transID_coln = "UMI_transID",
  transGene_coln = "target",
  cellID_coln = "UMI_cellID",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL,
  flagModel_TransNum_cutoff = 50,
  flagCell_lrtest_cutoff = 5,
  svmClass_score_cutoff = -2,
  svm_args = list(kernel = "radial", scale = FALSE, gamma = 0.4),
  molecular_distance_cutoff = 2.7,
  cellular_distance_cutoff = NULL,
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum = NULL,
  groupTranscripts_method = c("dbscan", "delaunay"),
  spatialMergeCheck_method = c("leidenCut", "geometryDiff"),
  cutoff_spatialMerge = 0.5,
  leiden_config = list(objective_function = "CPM", resolution_parameter = 1, beta = 0.01,
    n_iterations = 200),
  config_spatNW_transcript = NULL,
  return_intermediates = TRUE,
  return_perCellData = TRUE,
  includeAllRefGenes = FALSE,
  seed_process = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{score\_GeneMatrix}] the gene x cell-type matrix of log-like score of gene in each cell type

\item[\code{transcript\_df}] the data.frame for each transcript with columns for transcript\_id, target or gene name, original cell\_id, spatial coordinates.

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}

\item[\code{transGene\_coln}] the column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{extracellular\_cellID}] a vector of cell\_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)

\item[\code{flagModel\_TransNum\_cutoff}] the cutoff of transcript number to do spatial modeling for identification of wrongly segmented cells (default = 50)

\item[\code{flagCell\_lrtest\_cutoff}] the cutoff of lrtest\_nlog10P to identify putative wrongly segemented cells with strong spatial dependency in transcript score profile

\item[\code{svmClass\_score\_cutoff}] the cutoff of transcript score to separate between high and low score transcripts in SVM (default = -2)

\item[\code{svm\_args}] a list of arguments to pass to svm function for identifying low-score transcript groups in space, typically involve kernel, gamma, scale

\item[\code{molecular\_distance\_cutoff}] maximum molecule-to-molecule distance within connected transcript group, same unit as input spatial coordinate (default = 2.7 micron).
If set to NULL, the pipeline would first randomly choose no more than 2500 cells from up to 10 random picked ROIs with search radius to be 5 times of \code{cellular\_distance\_cutoff}, and then calculate the minimal molecular distance between picked cells. The pipeline would further use the 5 times of 90\% quantile of minimal molecular distance as \code{molecular\_distance\_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.

\item[\code{cellular\_distance\_cutoff}] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate. Default = NULL to use the 2 times of average 2D cell diameter.

\item[\code{score\_baseline}] a named vector of score baseline under each cell type listed in \code{score\_GeneMatrix} such that per cell transcript score higher than the baseline is required to call a cell type of high enough confidence

\item[\code{lowerCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is

\item[\code{higherCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type.

\item[\code{groupTranscripts\_method}] use either "dbscan" or "delaunay method" to group transcripts in space (default = "dbscan")

\item[\code{spatialMergeCheck\_method}] use either "leidenCut" (in 2D or 3D) or "geometryDiff" (in 2D only) method to determine whether a cell pair merging event is allowed in space (default = "leidenCut")

\item[\code{cutoff\_spatialMerge}] spatial constraint on a valid merging event between two source transcript groups, default = 0.5 for 50\% cutoff, set to 0 to skip spatial constraint evaluation for merging.
For \code{spatialMergeCheck\_method = "leidenCut"}, this is the minimal percentage of transcripts shared membership between query cell and neighbor cells in leiden clustering results for a valid merging event.
For \code{spatialMergeCheck\_method = "geometryDiff"}, this is the maximum percentage of white space change upon merging of query cell and neighbor cell for a valid merging event.

\item[\code{leiden\_config}] (leidenCut) a list of configuration to pass to reticulate and \code{igraph::cluster\_leiden} function, including objective\_function, resolution\_parameter, beta, n\_iterations.

\item[\code{config\_spatNW\_transcript}] configuration list to create spatial network at transcript level, see manual for \code{createSpatialDelaunayNW\_from\_spatLocs} for more details, set to NULL to use default config (default = NULL)

\item[\code{return\_intermediates}] flag to return intermediate outputs, including data.frame for spatial modeling statistics of each cell

\item[\code{return\_perCellData}] flag to return gene x cell count matrix and per cell DF with updated mean spatial coordinates and new cell type

\item[\code{includeAllRefGenes}] flag to include all genes in \code{score\_GeneMatrix} in the returned \code{updated\_perCellExprs} with missing genes of value 0 (default = FALSE)

\item[\code{seed\_process}] seed for per FOV processing, used in transcript error detection and correction steps, default = NULL to skip the seed
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The pipeline would score each transcript based on the provided cell type-specific reference profiles, evaluate the goodness-of-fit of each transcript within original cell segment, identify the low-score transcript groups within cells that has strong spatial dependency in transcript score profile, evaluate the neighborhood environment of low-score transcript groups and perform resegmentation actions including triming to extracellular space, merging to neighbor cell or labeling as new cell.

To account for genes missing in \code{score\_GeneMatrix} but present in input transcript data.frame, genes in \code{ctrl\_genes} would be assigned with goodness-of-fit score equal to \code{svmClass\_score\_cutoff} for all cell types to minimize the impact of those genes on the identification of low-score transcript groups via SVM. To avoid significant interference from those \code{ctrl\_genes}, it's recommended to have total counts of those genes below 1\% of total counts of all genes in each cell.
\end{Details}
%
\begin{Value}
a list
\begin{description}

\item[modStats\_ToFlagCells] a data.frame for spatial modeling statistics of each cell, output of \code{score\_cell\_segmentation\_error} function, return when \code{return\_intermediates} = TRUE
\item[groupDF\_ToFlagTrans] data.frame for the group assignment of transcripts within putative wrongly segmented cells, merged output of \code{flag\_bad\_transcripts} and \code{groupTranscripts\_Delaunay} or \code{groupTranscripts\_dbscan} functions, return when \code{return\_intermediates} = TRUE
\item[neighborhoodDF\_ToReseg] a data.frame for neighborhood environment of low-score transcript groups, output of \code{get\_neighborhood\_content} function, return when \code{return\_intermediates} = TRUE
\item[reseg\_actions] a list of 4 elements describing how the resegmenation would be performed on original \code{transcript\_df} by the group assignment of transcripts listed in \code{groupDF\_ToFlagTrans}, output of \code{decide\_ReSegment\_Operations} function, return when \code{return\_intermediates} = TRUE
\item[updated\_transDF] the updated transcript\_df with \code{updated\_cellID} and \code{updated\_celltype} column based on reseg\_full\_converter
\item[updated\_perCellDT] a per cell data.table with mean spatial coordinates, new cell type and resegmentation action after resegmentation, return when \code{return\_perCellData} = TRUE
\item[updated\_perCellExprs] a gene x cell count sparse matrix for updated transcript data.frame after resegmentation, return when \code{return\_perCellData} = TRUE

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data(example_refProfiles)
data(mini_transcriptDF)
data(example_baselineCT)
#' cell_ID for extracellualr transcripts
extracellular_cellID <- mini_transcriptDF[which(mini_transcriptDF$CellId ==0), 'cell_ID'] 
score_baseline <- example_baselineCT[['span_score']][,"25%"]
lowerCutoff_transNum  <- example_baselineCT[['span_transNum']][,"25%"]
higherCutoff_transNum  <- example_baselineCT[['span_transNum']][,"50%"]

# calculate log-likelihood of each gene under each cell type and center the 
# score matrix on per gene basis
score_GeneMatrix <- scoreGenesInRef(genes = intersect(unique(mini_transcriptDF[["target"]]), 
                                                      rownames(example_refProfiles)),
                                    ref_profiles = pmax(example_refProfiles, 1e-5))
                                    
# case 1: run with default methods: "dbscan" for transcript grouping, 
# "leidenCut" for merging check 
final_res1 <- fastReseg_perFOV_full_process(score_GeneMatrix= score_GeneMatrix,
                                           transcript_df = mini_transcriptDF,
                                           extracellular_cellID = extracellular_cellID,
                                           molecular_distance_cutoff = 2.7,
                                           cellular_distance_cutoff = 25,
                                           score_baseline = score_baseline,
                                           lowerCutoff_transNum = lowerCutoff_transNum,
                                           higherCutoff_transNum= higherCutoff_transNum)


# case 2: run with alternative methods: "delaunay" for transcript grouping, 
# "geometryDiff" for merging check 
final_res2 <- fastReseg_perFOV_full_process(score_GeneMatrix= score_GeneMatrix,
                                           transcript_df = mini_transcriptDF,
                                           extracellular_cellID = extracellular_cellID,
                                           molecular_distance_cutoff = 2.7,
                                           cellular_distance_cutoff = 25,
                                           score_baseline = score_baseline,
                                           lowerCutoff_transNum = lowerCutoff_transNum,
                                           higherCutoff_transNum= higherCutoff_transNum,
                                           groupTranscripts_method = "delaunay",
                                           spatialMergeCheck_method = "geometryDiff")


# case 3: run with default "dbscan" for transcript grouping, but apply no 
# spatial constraint on merging
final_res3 <- fastReseg_perFOV_full_process(score_GeneMatrix= score_GeneMatrix,
                                            transcript_df = mini_transcriptDF,
                                            extracellular_cellID = extracellular_cellID,
                                            molecular_distance_cutoff = 2.7,
                                            cellular_distance_cutoff = 25,
                                            score_baseline = score_baseline,
                                            lowerCutoff_transNum = lowerCutoff_transNum,
                                            higherCutoff_transNum= higherCutoff_transNum,
                                            cutoff_spatialMerge = 0)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{flagTranscripts\_LDA\_hyperplane}{flagTranscripts\_LDA\_hyperplane}{flagTranscripts.Rul.LDA.Rul.hyperplane}
%
\begin{Description}
find out the spatially connected transcripts among chosen\_transcripts based on LDA hyperplane spatial model which scores each cell for how much their transcripts change their goodness-of-fit over space.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
flagTranscripts_LDA_hyperplane(
  chosen_cells,
  score_GeneMatrix,
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  transGene_coln = "target",
  score_coln = "score",
  spatLocs_colns = c("x", "y", "z"),
  model_cutoff = 50,
  score_cutoff = -2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_cells}] the cell\_ID of chosen cells

\item[\code{score\_GeneMatrix}] the gene x cell-type matrix of log-like score of gene in each cell type

\item[\code{transcript\_df}] the data.frame of transcript\_ID, cell\_ID, score, spatial coordinates

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transGene\_coln}] the column name of target or gene name in transcript\_df

\item[\code{score\_coln}] the column name of score in transcript\_df

\item[\code{spatLocs\_colns}] the column names of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df

\item[\code{model\_cutoff}] the cutoff of transcript number to do spatial modeling (default = 50)

\item[\code{score\_cutoff}] the cutoff of score to separate between high and low score transcripts (default = -2)
\end{ldescription}
\end{Arguments}
%
\begin{Details}
For score of transcripts within each cell, assign 0 or 1 label to each transcript based on whether the score is above score\_cutoff; then run linear discriminant analysis on lda(above\_cutoff \textasciitilde{} x + y + xy + x\textasciicircum{}2 + y\textasciicircum{}2) for 2D, lda(above\_cutoff \textasciitilde{} x + y + z+ xy +xz + yz + x\textasciicircum{}2 + y\textasciicircum{}2 + z\textasciicircum{}2) for 3D. Coordinate variables with variance less than 1e-8 would not be used. Z-step of 5E-4mm or similar often resulted in too small of variables for z2.
\end{Details}
%
\begin{Value}
a data.frame
\begin{enumerate}

\item{} cellID\_coln, original cell id
\item{} LDA\_class, 0 for below cutoff, 1 for above cutoff
\item{} transID\_coln, original transcript\_id
\item{} transGene\_coln, target gene of transcript
\item{} score\_coln, score in transcript\_df
\item{} spatLocs\_colns for spatial coorindates of transcript
\item{} LD1, LD1 value of LDA model output
\item{} LDA\_cell\_type, new cell type for each transcript groups within each cells

\end{enumerate}

\end{Value}
\inputencoding{utf8}
\HeaderA{flag\_bad\_transcripts}{flag\_bad\_transcripts}{flag.Rul.bad.Rul.transcripts}
%
\begin{Description}
find out the spatially connected transcripts among chosen\_transcripts based on SVM spatial model which scores each cell for how much their transcripts change their goodness-of-fit over space.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
flag_bad_transcripts(
  chosen_cells,
  score_GeneMatrix,
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  transGene_coln = "target",
  score_coln = "score",
  spatLocs_colns = c("x", "y", "z"),
  model_cutoff = 50,
  score_cutoff = -2,
  svm_args = list(kernel = "radial", scale = TRUE, gamma = 0.1)
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_cells}] the cell\_ID of chosen cells

\item[\code{score\_GeneMatrix}] the gene x cell-type matrix of log-like score of gene in each cell type

\item[\code{transcript\_df}] the data.frame of transcript\_ID, cell\_ID, score, spatial coordinates

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transGene\_coln}] the column name of target or gene name in transcript\_df

\item[\code{score\_coln}] the column name of score in transcript\_df

\item[\code{spatLocs\_colns}] the column names of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df

\item[\code{model\_cutoff}] the cutoff of transcript number to do spatial modeling (default = 50)

\item[\code{score\_cutoff}] the cutoff of score to separate between high and low score transcripts (default = -2)

\item[\code{svm\_args}] a list of arguments to pass to svm function, typically involve kernel, gamma, scale
\end{ldescription}
\end{Arguments}
%
\begin{Details}
For score of transcripts within each cell, assign 0 or 1 label to each transcript based on whether the score is above score\_cutoff; then run support vector machine on svm(above\_cutoff \textasciitilde{} x + y) for 2D, svm(above\_cutoff \textasciitilde{} x + y + z) for 3D, default to do radial kernal with scale = TRUE and gamma = 0.1.
\end{Details}
%
\begin{Value}
a data.frame
\begin{enumerate}

\item{} cellID\_coln, original cell id
\item{} SVM\_class, 0 for below cutoff, 1 for above cutoff
\item{} transID\_coln, original transcript\_id
\item{} transGene\_coln, target gene of transcript
\item{} score\_coln, score in transcript\_df
\item{} spatLocs\_colns for spatial coorindates of transcript
\item{} DecVal, decision values of svm model output
\item{} SVM\_cell\_type, new cell type for each transcript groups within each cells

\end{enumerate}

\end{Value}
\inputencoding{utf8}
\HeaderA{getCellType\_maxScore}{getCellType\_maxScore}{getCellType.Rul.maxScore}
%
\begin{Description}
get the cell type give maximum score
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getCellType_maxScore(
  score_GeneMatrix,
  transcript_df,
  transGene_coln = "target",
  cellID_coln = "cell_ID"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{score\_GeneMatrix}] a gene x cell-type score matrix

\item[\code{transcript\_df}] the data.frame of transcript\_ID and cell\_ID

\item[\code{transGene\_coln}] the column name of target or gene name in transcript\_df

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df
\end{ldescription}
\end{Arguments}
%
\begin{Value}
return a named vector with cell type in values and cell\_ID in names
\end{Value}
\inputencoding{utf8}
\HeaderA{getNeighbors\_transDF}{getNeighbors\_transDF}{getNeighbors.Rul.transDF}
%
\begin{Description}
find neighbor cells of chosen\_cells and return the relevant transcript data.frame for both query
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getNeighbors_transDF(
  chosen_cells = NULL,
  neighbor_distance_xy = NULL,
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  transSpatLocs_coln = c("x", "y", "z")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_cells}] the cell\_ID of chosen cells need to be evaluate for re-segmentation

\item[\code{neighbor\_distance\_xy}] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate. Default = NULL to use the 2 times of average cell diameter.

\item[\code{transcript\_df}] the data.frame with transcript\_id, cell\_id and spatial coordinates

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transSpatLocs\_coln}] the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df
\end{ldescription}
\end{Arguments}
%
\begin{Details}
get neighborhood transcript data frame for visualization

Locate neighbor cells of each query cell in 1st and 2nd dimension via cell-to-cell distance within neighbor\_distance\_xy. If no neighbor cells found for query cell, return query cell information only. Do not consider extracellular transcripts.
\end{Details}
%
\begin{Value}
a data.frame
\begin{enumerate}

\item{} transcript\_id, transcript id of all transcript near chosen cell's neighborhood
\item{} transSpatLocs\_coln, coordinates
\item{} in\_query\_cell, flag whether current transcript is in the query cell, false means in neighbor cells
\item{} CellId, original cell id of each transcript
\item{} query\_CellId, original query cell id of transcript's neighborhood

\end{enumerate}

\end{Value}
\inputencoding{utf8}
\HeaderA{getScoreCellType\_gene}{getScoreCellType\_gene}{getScoreCellType.Rul.gene}
%
\begin{Description}
get each transcript's score based on score matrix and chosen cell-type
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getScoreCellType_gene(
  score_GeneMatrix,
  transcript_df,
  transID_coln = "transcript_id",
  transGene_coln = "target",
  celltype_coln = "cell_type"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{score\_GeneMatrix}] a gene x cell-type score matrix

\item[\code{transcript\_df}] the data.frame of transcript\_ID and cell\_ID

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transGene\_coln}] the column name of target or gene name in transcript\_df

\item[\code{celltype\_coln}] the column name of cell type in transcript\_df
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a named vector with score of given cell type in values and transcript\_id in names
\end{Value}
\inputencoding{utf8}
\HeaderA{get\_baselineCT}{get\_baselineCT}{get.Rul.baselineCT}
%
\begin{Description}
get cluster-specific quantile distribution of transcript number and per cell per molecule transcript score in the provided cell x gene expression matrix based on the reference profiles and cell cluster assignment
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_baselineCT(refProfiles, counts, clust = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{refProfiles}] A matrix of cluster profiles, genes X clusters

\item[\code{counts}] Counts matrix, cells X genes.

\item[\code{clust}] Vector of cluster assignments for each cell in \code{counts}, default = NULL to automatically assign the cell cluster for each cell based on maximum transcript score
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Calculate average per molecule transcript score for each cell in \code{counts} expression matrix based on the provided cluster profiles \code{refProfiles} and cluster assignment for each cell \code{clust}; then get the quantile distribution of transcript number and per molecule per cell transcript score under each cluster. The function would also recommend the cutoff for transcript score and transcript number to be used in re-segmentation pipeline based on the calculated quantile distribution.
\end{Details}
%
\begin{Value}
a list
\begin{enumerate}

\item{} span\_score, a matrix of average transcript tLLR score per molecule per cell for 22 distinct cell types in rows, percentile at (0\%, 25\%, 50\%, 75\%, 100\%) in columns
\item{} span\_transNum, a matrix of transcript number per cell for each distinct cell types in row, percentile at (0\%, 25\%, 50\%, 75\%, 100\%) in columns
\item{} score\_baseline, a named vector of 25\% quantile of cluster-specific per cell transcript score, to be used as score baseline such that  per cell transcript score higher than the baseline is required to call a cell type of high enough confidence
\item{} lowerCutoff\_transNum, a named vector of 25\% quantile of cluster-specific per molecule per cell transcript number, to be used as transcript number cutoff such that higher than the cutoff is required to keep query cell as it is
\item{} higherCutoff\_transNum, a named vector of median value of cluster-specific per molecule per cell transcript number, to be used as transcript number cutoff such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type.
\item{} clust\_used,  a named vector of cluster assignments for each cell used in baseline calculation, cell\_ID in \code{counts} as name

\end{enumerate}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data(example_refProfiles)
data(ori_RawExprs)
baselineData <- get_baselineCT(refProfiles = example_refProfiles, 
                               counts = ori_RawExprs, clust = NULL)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{get\_neighborhood\_content}{get\_neighborhood\_content}{get.Rul.neighborhood.Rul.content}
%
\begin{Description}
find neighbor cells with transcripts that are direct neighbor of chosen\_cell, check tLLRv2 score under neighbor cell type, return neighborhood information
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_neighborhood_content(
  chosen_cells = NULL,
  score_GeneMatrix,
  score_baseline = NULL,
  neighbor_distance_xy = NULL,
  distance_cutoff = 2.7,
  transcript_df,
  cellID_coln = "CellId",
  celltype_coln = "cell_type",
  transID_coln = "transcript_id",
  transGene_coln = "target",
  transSpatLocs_coln = c("x", "y", "z")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_cells}] the cell\_ID of chosen cells need to be evaluate for re-segmentation

\item[\code{score\_GeneMatrix}] the gene x cell-type matrix of log-like score of gene in each cell type

\item[\code{score\_baseline}] a named vector of score baseline for all cell type listed in score\_GeneMatrix

\item[\code{neighbor\_distance\_xy}] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate. Default = NULL to use the 2 times of average 2D cell diameter.

\item[\code{distance\_cutoff}] maximum molecule-to-molecule distance within connected transcript group, same unit as input spatial coordinate (default = 2.7 micron).
If set to NULL, the pipeline would first randomly choose no more than 2500 cells from up to 10 random picked ROIs with search radius to be 5 times of \code{neighbor\_distance\_xy}, and then calculate the minimal molecular distance between picked cells. The pipeline would further use the 5 times of 90\% quantile of minimal molecular distance as \code{distance\_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.

\item[\code{transcript\_df}] the data.frame with transcript\_id, target/geneName, x, y and cell\_id

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{celltype\_coln}] the column name of cell\_type in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transGene\_coln}] the column name of target or gene name in transcript\_df

\item[\code{transSpatLocs\_coln}] the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Locate neighbor cells of each query cell firstly via cell-to-cell distance in 2D plane within neighbor\_distance\_xy, then via molecule-to-molecule 3D distance within distance\_cutoff. If no neighbor cells found for query cell, use the cell id and cell type of query cell to fill in the columns for neighbor cells in returned data.frame
\end{Details}
%
\begin{Value}
a data.frame
\#' \begin{enumerate}

\item{} CellId, original cell id of chosen cells
\item{} cell\_type, original cell type of chosen cells
\item{} transcript\_num, number of transcripts in chosen cells
\item{} self\_celltype, cell type give maximum score for query cell only
\item{} score\_under\_self, score in query cell under its own maximum celltype
\item{} neighbor\_CellId, cell id of neighbor cell whose cell type gives maximum score in query cell among all neighbors, not including query cell itself
\item{} neighbor\_celltype, cell type that gives maximum score in query cell among all non-self neighbor cells
\item{} score\_under\_neighbor, score in query cell under neighbor\_celltype

\end{enumerate}

\end{Value}
\inputencoding{utf8}
\HeaderA{groupTranscripts\_dbscan}{groupTranscripts\_dbscan}{groupTranscripts.Rul.dbscan}
%
\begin{Description}
group the flagged transcript within each cell based on spatial clustering using dbscan
\end{Description}
%
\begin{Usage}
\begin{verbatim}
groupTranscripts_dbscan(
  chosen_transcripts = NULL,
  distance_cutoff = "auto",
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  transSpatLocs_coln = c("x", "y", "z")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_transcripts}] the transcript\_id of chosen transcript

\item[\code{distance\_cutoff}] maximum molecule-to-molecule distance within same transcript group (default = "auto")

\item[\code{transcript\_df}] the data.frame with transcript\_id, target/geneName, x, y and cell\_id

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transSpatLocs\_coln}] the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df
\end{ldescription}
\end{Arguments}
%
\begin{Details}
For query cell, group flagged transcripts only based on their molecular distance to each other. When distance cutoff = 'auto', use 20\% average XY cell range as cutoff. In case of no more than 3 flagged transcripts per cell, determine the grouping based on distance cutoff directly. In case of more transcripts per cell, use \code{dbscan} to group transcripts with distance\_cutoff as \code{eps} and \code{minPts = 1}.
\end{Details}
%
\begin{Value}
data frame of connected transcripts among chosen\_transcripts
\#' \begin{enumerate}

\item{} cellID\_coln, orignal cell\_ID
\item{} transID\_coln, connected transcripts among chosen\_transcripts
\item{} transSpatLocs\_coln, spatial coordinates of transcript
\item{} transcript\_group, group of chosen\_transcripts

\end{enumerate}

\end{Value}
\inputencoding{utf8}
\HeaderA{groupTranscripts\_Delaunay}{groupTranscripts\_Delaunay}{groupTranscripts.Rul.Delaunay}
%
\begin{Description}
group the flagged transcript within each cell based on spatial connectivity of their transcript delaunay network
\end{Description}
%
\begin{Usage}
\begin{verbatim}
groupTranscripts_Delaunay(
  chosen_transcripts = NULL,
  config_spatNW_transcript = list(name = "transcript_delaunay_network", dimensions =
    "all", method = "Delaunay", minimum_k = 0, delaunay_method = "delaunayn_geometry",
    maximum_distance_delaunay = "auto", options = "Pp", Y = TRUE, j = TRUE, S = 0),
  distance_cutoff = "auto",
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  transSpatLocs_coln = c("x", "y", "z")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_transcripts}] the transcript\_id of chosen transcript

\item[\code{config\_spatNW\_transcript}] configuration list to create spatial network at transcript level, see manual for \code{createSpatialDelaunayNW\_from\_spatLocs} for more details

\item[\code{distance\_cutoff}] maximum distance within connected transcript group (default = "auto")

\item[\code{transcript\_df}] the data.frame with transcript\_id, target/geneName, x, y and cell\_id

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transSpatLocs\_coln}] the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df
\end{ldescription}
\end{Arguments}
%
\begin{Details}
for query cell, build network on flagged transcripts only to identify groups. In case of no more than 3 transcripts, determine the grouping based on distance cutoff directly; when distance cutoff = 'auto', no additional edge filtering based on delaunay network output but use 20\% average XY cell range as cutoff when no more than 3 transcript.
\end{Details}
%
\begin{Value}
data frame of connected transcripts among chosen\_transcripts
\#' \begin{enumerate}

\item{} cellID\_coln, orignal cell\_ID
\item{} transID\_coln, connected transcripts among chosen\_transcripts
\item{} transSpatLocs\_coln, spatial coordinates of transcript
\item{} transcript\_group, group of chosen\_transcripts

\end{enumerate}

\end{Value}
\inputencoding{utf8}
\HeaderA{initializeAllSegRes}{initializeAllSegRes}{initializeAllSegRes}
%
\begin{Description}
initialize result holder for \code{fastReseg\_full\_pipeline} based on preprocessed data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
initializeAllSegRes(
  prep_res,
  save_intermediates = TRUE,
  return_perCellData = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{prep\_res}] nested list of elements for 'refProfiles', 'baselineData', 'cutoffs\_list', outputs of \code{runPreprocess}

\item[\code{save\_intermediates}] flag to save intermediate outputs into output folder, including data.frame for spatial modeling statistics of each cell,

\item[\code{return\_perCellData}] flag to return and save to output folder for gene x cell count matrix and per cell DF with updated mean spatial coordinates and new cell type
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list
\begin{description}

\item[refProfiles] a genes X clusters matrix of cluster-specific reference profiles used in resegmenation pipeline
\item[baselineData] a list of two matrice in cluster X percentile format for the cluster-specific percentile distribution of per cell value; \code{span\_score} is for the average per molecule transcript tLLR score of each cell, \code{span\_transNum} is for the transcript number of each cell.
\item[cutoffs\_list] a list of cutoffs used in resegmentation pipeline, including, \code{score\_baseline}, \code{lowerCutoff\_transNum}, \code{higherCutoff\_transNum}, \code{cellular\_distance\_cutoff}, \code{molecular\_distance\_cutoff}
\item[ctrl\_genes] a vector of control genes whose transcript scores are set to fixed value for all cell types
\item[updated\_perCellDT] an empty list, return when \code{return\_perCellData} = TRUE
\item[updated\_perCellExprs] an empty list, return when \code{return\_perCellData} = TRUE
\item[reseg\_actions] a list of 4 empty elements, same output format as \code{decide\_ReSegment\_Operations}, return when \code{save\_intermediates} = TRUE

\end{description}

\end{Value}
\inputencoding{utf8}
\HeaderA{makeDummyOuts\_perFOV}{makeDummyOuts\_perFOV}{makeDummyOuts.Rul.perFOV}
%
\begin{Description}
supporting function for \code{fastReseg\_perFOV\_full\_process}, makes dummy outputs based on input \code{transcript\_df} in same format as the outputs of \code{fastReseg\_perFOV\_full\_process()} but returns no \code{modStats\_ToFlagCells} data.frame, used in case of no cells being flagged for cell segmentation error.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
makeDummyOuts_perFOV(
  all_genes,
  transcript_df,
  transID_coln = "UMI_transID",
  transGene_coln = "target",
  cellID_coln = "UMI_cellID",
  spatLocs_colns = c("x", "y", "z"),
  return_intermediates = TRUE,
  return_perCellData = TRUE,
  includeAllRefGenes = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{all\_genes}] vector of all genes consider in the analysis as listed in rows of \code{score\_GeneMatrix} in parent function

\item[\code{transcript\_df}] the data.frame for each transcript with columns for transcript\_id, target or gene name, original cell\_id, spatial coordinates, as well as \code{tLLR\_maxCellType} and \code{score\_tLLR\_maxCellType} columns from earlier step in parent function

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}

\item[\code{transGene\_coln}] the column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{return\_intermediates}] flag to return intermediate outputs, including data.frame for spatial modeling statistics of each cell

\item[\code{return\_perCellData}] flag to return gene x cell count matrix and per cell DF with updated mean spatial coordinates and new cell type

\item[\code{includeAllRefGenes}] flag to include all genes in \code{score\_GeneMatrix} in the returned \code{updated\_perCellExprs} with missing genes of value 0 (default = FALSE)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list
\begin{description}

\item[groupDF\_ToFlagTrans] data.frame for the group assignment of transcripts within putative wrongly segmented cells, merged output of \code{flag\_bad\_transcripts} and \code{groupTranscripts\_Delaunay} or \code{groupTranscripts\_dbscan} functions, return when \code{return\_intermediates} = TRUE
\item[neighborhoodDF\_ToReseg] a data.frame for neighborhood environment of low-score transcript groups, output of \code{get\_neighborhood\_content} function, return when \code{return\_intermediates} = TRUE
\item[reseg\_actions] a list of 4 elements describing how the resegmenation would be performed on original \code{transcript\_df} by the group assignment of transcripts listed in \code{groupDF\_ToFlagTrans}, output of \code{decide\_ReSegment\_Operations} function, return when \code{return\_intermediates} = TRUE
\item[updated\_transDF] the updated transcript\_df with \code{updated\_cellID} and \code{updated\_celltype} column based on reseg\_full\_converter
\item[updated\_perCellDT] a per cell data.table with mean spatial coordinates, new cell type and resegmentation action after resegmentation, return when \code{return\_perCellData} = TRUE
\item[updated\_perCellExprs] a gene x cell count sparse matrix for updated transcript data.frame after resegmentation, return when \code{return\_perCellData} = TRUE

\end{description}

\end{Value}
\inputencoding{utf8}
\HeaderA{mini\_transcriptDF}{Transcript level data frame from Example dataset for spatial transcriptional profiling of tissue}{mini.Rul.transcriptDF}
\keyword{datasets}{mini\_transcriptDF}
%
\begin{Description}
The example dataset is based on one run of SMI RNA readout for FFPE melanoma tissue samples. It contains information for 1375 cells with 756783 transcripts within a cropped region of one single FOV of 1 tissue section.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(mini_transcriptDF)
\end{verbatim}
\end{Usage}
%
\begin{Format}
An object of class \code{"data.frame"} with 756783 transcripts in row and 9 variables
\begin{description}

\item[UMI\_transID] unique id for transcript
\item[UMI\_cellID] unique id for cell based on original cell segmentaion assignment
\item[x] spatial coordinate of the transcript in x-axis of the given FOV, unit in micron
\item[y] spatial coordinate of the transcript in y-axis of the given FOV, unit in micron
\item[z] spatial coordinate of the transcript in z-axis of the given FOV, unit in micron
\item[target] gene identity of given transcript
\item[slide] slide ID of given transcript
\item[fov] fov ID of given transcript
\item[CellId] the cell label assignment of given transcript within given FOV based on original cell segmentation

\end{description}

\end{Format}
%
\begin{SeeAlso}
\LinkA{ori\_CellStatsDF}{ori.Rul.CellStatsDF} for corresponding cell level dataset, \LinkA{ori\_RawExprs}{ori.Rul.RawExprs} for corresponding cell x gene expression matrix
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{myFun\_3point\_singleCell}{myFun\_3point\_singleCell}{myFun.Rul.3point.Rul.singleCell}
%
\begin{Description}
supporting function for \code{groupTranscripts\_Delaunay}, assign group ID for 3 transcripts in single cell in 3D based on distant cutoff
\end{Description}
%
\begin{Usage}
\begin{verbatim}
myFun_3point_singleCell(
  dfCoord_subset,
  transSpatLocs_coln = c("x", "y", "z"),
  distance_cutoff = 2.7,
  startGroup = 1
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dfCoord\_subset}] transcript data.table for single cell with only 3 transcripts in rows

\item[\code{transSpatLocs\_coln}] the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df

\item[\code{distance\_cutoff}] maximum distance within connected transcript group

\item[\code{startGroup}] the index of starting group ID
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.table with \code{transcript\_group} column added to original input data.table
\end{Value}
\inputencoding{utf8}
\HeaderA{myFun\_fov\_load}{myFun\_fov\_load}{myFun.Rul.fov.Rul.load}
%
\begin{Description}
supporting function for \code{runPreprocess}, \code{fastReseg\_full\_pipeline} and \code{fastReseg\_flag\_all\_errors}, to load transcript data.frame of each FOV from file path
\end{Description}
%
\begin{Usage}
\begin{verbatim}
myFun_fov_load(path_to_fov)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path\_to\_fov}] file path to per fov transcript data.frame
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{numCores}{Get number of cores for parallelized operations}{numCores}
%
\begin{Description}
Get number of cores for parallelized operations
\end{Description}
%
\begin{Usage}
\begin{verbatim}
numCores(percentCores = 0.9, minNotUsedCores = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{percentCores}] percent of cores to use for parallelization, value range 0 to 1

\item[\code{minNotUsedCores}] minimum number of cores to leave for background processes
\end{ldescription}
\end{Arguments}
%
\begin{Value}
number of cores to use for mclapply
\end{Value}
\inputencoding{utf8}
\HeaderA{ori\_CellStatsDF}{Cell level data frame from Example dataset for spatial transcriptional profiling of tissue}{ori.Rul.CellStatsDF}
\keyword{datasets}{ori\_CellStatsDF}
%
\begin{Description}
The example dataset is based on one run of SMI RNA readout for FFPE melanoma tissue samples. It contains information for 1375 cells with 756783 transcripts within a cropped region of one single FOV of 1 tissue section.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(ori_CellStatsDF)
\end{verbatim}
\end{Usage}
%
\begin{Format}
An object of class \code{"data.frame"} with 1375 cells in row and 10 variables
\begin{description}

\item[cell\_ID] unique id for cell based on original cell segmentaion assignment
\item[slide] slide ID of given cell
\item[fov] fov ID of given cell
\item[CellId] the cell label assignment of given cell within given FOV based on original cell segmentation
\item[CenterX] spatial coordinate of the cell centroid in x-axis of the given FOV, unit in micron
\item[CenterY] spatial coordinate of the cell centroid in y-axis of the given FOV, unit in micron
\item[Width] the bounding box length of given cell segment along x-axis, unit in micron
\item[Height] the bounding box length of given cell segment along y-axis, unit in micron
\item[Area] the area of given cell segment, unit in square micron
\item[AspectRatio] the aspect ratio of boundingbox width over height for given cell segment

\end{description}

\end{Format}
%
\begin{SeeAlso}
\LinkA{mini\_transcriptDF}{mini.Rul.transcriptDF} for corresponding transcript level dataset, \LinkA{ori\_RawExprs}{ori.Rul.RawExprs} for corresponding cell x gene expression matrix
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{ori\_RawExprs}{Cell x Gene expression matrix from Example dataset for spatial transcriptional profiling of tissue}{ori.Rul.RawExprs}
\keyword{datasets}{ori\_RawExprs}
%
\begin{Description}
The example dataset is based on one run of SMI RNA readout for FFPE melanoma tissue samples. It contains the single cell gene expression profile for 1375 cells across 960 genes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(ori_RawExprs)
\end{verbatim}
\end{Usage}
%
\begin{Format}
An object of class \code{"matrix"} with 4619 cells in row and 960 genes in columns
\end{Format}
%
\begin{SeeAlso}
\LinkA{mini\_transcriptDF}{mini.Rul.transcriptDF} for corresponding transcript level dataset, \LinkA{ori\_CellStatsDF}{ori.Rul.CellStatsDF} for corresponding cell level dataset
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{plotSpatialScoreMultiCells}{plotSpatialScoreMultiCells}{plotSpatialScoreMultiCells}
%
\begin{Description}
plot spatial plot of transcripts within chosen cells, colored by score, facet by cell\_ID
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotSpatialScoreMultiCells(
  chosen_cells,
  cell_labels,
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  score_coln = "score",
  spatLocs_colns = c("x", "y"),
  point_size = 0.1,
  plot_discrete = FALSE,
  title = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_cells}] the cell\_ID of chosen cells

\item[\code{cell\_labels}] title labels for each cell's spatial plot

\item[\code{transcript\_df}] the data.frame of transcript\_ID, cell\_ID, spatial locations

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{score\_coln}] the column name of score in transcript\_df

\item[\code{spatLocs\_colns}] column names for 1st, 2nd dimension of spatial coordinates in transcript\_df

\item[\code{point\_size}] marker size for transcript spot in fig (default = 0.1)

\item[\code{plot\_discrete}] flag to plot transcript score in discrete color

\item[\code{title}] the text title for plot
\end{ldescription}
\end{Arguments}
%
\begin{Value}
ggplot
\end{Value}
\inputencoding{utf8}
\HeaderA{prepare\_perFOV\_transDF}{prepare\_perFOV\_transDF}{prepare.Rul.perFOV.Rul.transDF}
%
\begin{Description}
supporting function for \code{runPreprocess}, \code{fastReseg\_internalRef} and \code{fastReseg\_flag\_all\_errors} to get unique IDs for cells and transcripts, and convert pixel coordinates to um; when \AsIs{\texttt{drop\_original = FALSE, the function will also return original per FOV based cell ID and coordinates under columns }}CellId\AsIs{\texttt{, }}pixel\_x\AsIs{\texttt{, }}pixel\_y\AsIs{\texttt{, }}idx\_z`.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
prepare_perFOV_transDF(
  each_transDF,
  fov_centerLocs,
  prefix_vals = NULL,
  pixel_size = 0.18,
  zstep_size = 0.8,
  transID_coln = NULL,
  transGene_coln = "target",
  cellID_coln = "CellId",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL,
  drop_original = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{each\_transDF}] data.frame for raw transcript

\item[\code{fov\_centerLocs}] a named vector of fov 2D coordinates

\item[\code{prefix\_vals}] a named vector of values to be used as prefix in \code{UMI\_transID} and \code{UMI\_cellID}; when \code{prefix\_vals} != NULL, unique transcript\_id would be generated from \code{prefix\_vals} and \code{transID\_coln} in \code{each\_transDF}

\item[\code{pixel\_size}] the micrometer size of image pixel listed in 1st and 2nd dimension of \code{spatLocs\_colns} of \code{each\_transDF}

\item[\code{zstep\_size}] the micrometer size of z-step for the optional 3rd dimension of \code{spatLocs\_colns} of \code{each\_transDF}

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}, default = NULL to use row index of transcript in \code{each\_transDF}; when \code{prefix\_vals} != NULL, unique transcript\_id would be generated from \code{prefix\_vals} and \code{transID\_coln} in \code{each\_transDF}

\item[\code{transGene\_coln}] the column name of target or gene name in \code{each\_transDF}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{each\_transDF}; when \code{prefix\_colns} != NULL, unique cell\_ID would be generated from \code{prefix\_vals} and \code{cellID\_coln} in each \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{each\_transDF}

\item[\code{extracellular\_cellID}] a vector of cell\_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)

\item[\code{drop\_original}] flag to drop original per FOV based cell ID and coordinates under columns \code{CellId}, \code{pixel\_x}, \code{pixel\_y}, \code{idx\_z} (default = FALSE)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list contains transcript\_df for downstream process and extracellular transcript data.frame
' \begin{description}

\item[intraC] a data.frame for intracellular transcript, \code{UMI\_transID} and \code{UMI\_cellID} as column names for unique transcript\_id and cell\_id, \code{target} as column name for target gene name
\item[extraC] a data.frame for extracellular transcript, same structure as the \code{intraC} data.frame in returned list

\end{description}

\end{Value}
\inputencoding{utf8}
\HeaderA{prepResegDF}{prepResegDF}{prepResegDF}
%
\begin{Description}
supporting function for \code{fastReseg\_perFOV\_full\_process}, combine \code{runTranscriptErrorDetection()} output with transcript data.frame to prep for \code{runSegRefinement()}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
prepResegDF(
  transcript_df,
  groupDF_ToFlagTrans,
  cellID_coln = "UMI_cellID",
  transID_coln = "UMI_transID"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{transcript\_df}] the data.frame for each transcript with columns for transcript\_id, target or gene name, original cell\_id, spatial coordinates and \code{tLLR\_maxCellType}.

\item[\code{groupDF\_ToFlagTrans}] data frame for transcripts in \code{chosen\_cells} only, with columns for \code{connect\_group},\code{tmp\_cellID},\code{group\_maxCellType}, output of \code{runTranscriptErrorDetection()}

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list of two elements
\begin{description}

\item[reseg\_transcript\_df] data.frame with transcript\_id, target/geneName, x, y, cell\_id for all transcript groups \code{tmp\_cellID} and the cell type of maximum transcript scores for each transcript group \code{group\_maxCellType}
\item[groups\_to\_reseg] vector of chosen transcript groups need to be evaluate for re-segmentation

\end{description}

\end{Value}
\inputencoding{utf8}
\HeaderA{runPreprocess}{runPreprocess}{runPreprocess}
%
\begin{Description}
modular wrapper to get baseline data and cutoffs from entire dataset
\end{Description}
%
\begin{Usage}
\begin{verbatim}
runPreprocess(
  counts,
  clust = NULL,
  refProfiles = NULL,
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum = NULL,
  imputeFlag_missingCTs = TRUE,
  ctrl_genes = NULL,
  svmClass_score_cutoff = -2,
  molecular_distance_cutoff = 2.7,
  cellular_distance_cutoff = NULL,
  transcript_df = NULL,
  transDF_fileInfo = NULL,
  filepath_coln = "file_path",
  prefix_colns = c("slide", "fov"),
  fovOffset_colns = c("stage_X", "stage_Y"),
  pixel_size = 0.18,
  zstep_size = 0.8,
  transID_coln = NULL,
  transGene_coln = "target",
  cellID_coln = "CellId",
  spatLocs_colns = c("x", "y", "z"),
  extracellular_cellID = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{counts}] Counts matrix for entire dataset, cells X genes.

\item[\code{clust}] Vector of cluster assignments for each cell in \code{counts}, when NULL to automatically assign the cell cluster for each cell based on maximum transcript score of given the provided \code{refProfiles}

\item[\code{refProfiles}] A matrix of cluster profiles, genes X clusters, default = NULL to use external cluster assignments.
Of note, when \code{refProfiles !=  NULL}, genes unique to \code{counts} but missing in \code{refProfiles} would be omitted from downstream analysis.

\item[\code{score\_baseline}] a named vector of score baseline under each cell type listed in \code{refProfiles} such that  per cell transcript score higher than the baseline is required to call a cell type of high enough confidence; default = NULL to calculate from \code{counts} and \code{refProfiles}

\item[\code{lowerCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is; default = NULL to calculate from \code{counts} and \code{refProfiles}

\item[\code{higherCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type; default = NULL to calculate from \code{counts} and \code{refProfiles}

\item[\code{imputeFlag\_missingCTs}] flag to impute \code{score\_baseline}, \code{lowerCutoff\_transNum},\code{higherCutoff\_transNum} for cell types present in \code{refProfiles} but missing in the provided transcript data files or the provided baseline and cutoffs; when TRUE, the median values of existing cell types would be used as the values for missing cell types.

\item[\code{ctrl\_genes}] a vector of control genes that are present in input transcript data.frame but not in \code{refProfiles} and expect no cell type dependency, e.g. negative control probes; the \code{ctrl\_genes} would be included in FastReseg analysis. (default = NULL)

\item[\code{svmClass\_score\_cutoff}] the cutoff of transcript score to separate between high and low score transcripts in SVM, used as the score values for \code{ctrl\_genes} (default = -2)

\item[\code{molecular\_distance\_cutoff}] maximum molecule-to-molecule distance within connected transcript group, unit in micron (default = 2.7 micron).
If set to NULL, the pipeline would first randomly choose no more than 2500 cells from up to 10 random picked ROIs with search radius to be 5 times of \code{cellular\_distance\_cutoff}, and then calculate the minimal molecular distance between picked cells. The pipeline would further use the 5 times of 90\% quantile of minimal molecular distance as \code{molecular\_distance\_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.

\item[\code{cellular\_distance\_cutoff}] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, unit in micron. Default = NULL to use the 2 times of average 2D cell diameter.

\item[\code{transcript\_df}] the data.frame of transcript level information with unique CellId, default = NULL to read from the \code{transDF\_fileInfo}

\item[\code{transDF\_fileInfo}] a data.frame with each row for each individual file of per FOV transcript data.frame within which the coordinates and CellId are unique, columns include the file path of per FOV transcript data.frame file, annotation columns like slide and fov to be used as prefix when creating unique cell\_ID across entire dataset; when NULL, use the provided \code{transcript\_df} directly

\item[\code{filepath\_coln}] the column name of each individual file of per FOV transcript data.frame in \code{transDF\_fileInfo}

\item[\code{prefix\_colns}] the column names of annotation in \code{transDF\_fileInfo}, to be added to the CellId as prefix when creating unique cell\_ID for entire dataset; set to NULL if use the original \code{transID\_coln} or \code{cellID\_coln}

\item[\code{fovOffset\_colns}] the column name of coordinate offsets in 1st and 2nd dimension for each per FOV transcript data.frame in \code{transDF\_fileInfo}, unit in micron
Notice that some assays like SMI has XY axes swapped between stage and each FOV such that \code{fovOffset\_colns} should be c("stage\_Y", "stage\_X").

\item[\code{pixel\_size}] the micrometer size of image pixel listed in 1st and 2nd dimension of \code{spatLocs\_colns} of each \code{transcript\_df}

\item[\code{zstep\_size}] the micrometer size of z-step for the optional 3rd dimension of \code{spatLocs\_colns} of each \code{transcript\_df}

\item[\code{transID\_coln}] the column name of transcript\_ID in \code{transcript\_df}, default = NULL to use row index of transcript in each \code{transcript\_df}; when \code{prefix\_colns} != NULL, unique transcript\_id would be generated from \code{prefix\_colns} and \code{transID\_coln} in each \code{transcript\_df}

\item[\code{transGene\_coln}] the column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}; when \code{prefix\_colns} != NULL, unique cell\_ID would be generated from \code{prefix\_colns} and \code{cellID\_coln} in each \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{extracellular\_cellID}] a vector of cell\_ID for extracellular transcripts which would be removed from the resegmention pipeline (default = NULL)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a nested list
\begin{description}

\item[clust] vector of cluster assignments for each cell in \code{counts}, used in caculating \code{baselineData}
\item[refProfiles] a genes X clusters matrix of cluster-specific reference profiles to use in resegmenation pipeline
\item[baselineData] a list of two matrice in cluster X percentile format for the cluster-specific percentile distribution of per cell value; \code{span\_score} is for the average per molecule transcript tLLR score of each cell, \code{span\_transNum} is for the transcript number of each cell.
\item[cutoffs\_list] a list of cutoffs to use in resegmentation pipeline, including, \code{score\_baseline}, \code{lowerCutoff\_transNum}, \code{higherCutoff\_transNum}, \code{cellular\_distance\_cutoff}, \code{molecular\_distance\_cutoff}
\item[ctrl\_genes] a vector of control genes whose transcript scores are set to fixed value for all cell types, return when \code{ctrl\_genes} is not NULL.
\item[score\_GeneMatrix] a gene x cell-type score matrix to use in resegmenation pipeline, the scores for \code{ctrl\_genes} are set to be the same as \code{svmClass\_score\_cutoff}
\item[processed\_1st\_transDF] a list of 2 elements for the intracellular and extracellular transcript data.frame of the processed outcomes of 1st transcrip file

\end{description}

The \code{cutoffs\_list} is a list containing
\begin{description}

\item[score\_baseline] a named vector of score baseline under each cell type listed in \code{refProfiles} such that  per cell transcript score higher than the baseline is required to call a cell type of high enough confidence.
\item[lowerCutoff\_transNum] a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is.
\item[higherCutoff\_transNum] a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type.
\item[cellular\_distance\_cutoff] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, unit in micron. 
\item[molecular\_distance\_cutoff] maximum molecule-to-molecule distance within connected transcript group, unit in micron.

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 
data("mini_transcriptDF")
data("example_CellGeneExpr")
data("example_clust")
data("example_refProfiles")
# cell_ID for extracellualr transcripts
extracellular_cellID <- mini_transcriptDF[which(mini_transcriptDF$CellId ==0), 'cell_ID'] 

# case 1: use `clust` and `transcript_df` directly, with known distance cutoffs
prep_res1 <- runPreprocess(
  counts = example_CellGeneExpr,
  clust = example_clust,
  refProfiles = NULL,
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum= NULL,
  imputeFlag_missingCTs = FALSE,
  ctrl_genes = NULL,
  svmClass_score_cutoff = -2,
  molecular_distance_cutoff = 2.7,
  cellular_distance_cutoff = 20,
  transcript_df = mini_transcriptDF, 
  transDF_fileInfo = NULL, 
  pixel_size = 0.18,
  zstep_size = 0.8, 
  transID_coln = NULL,
  transGene_coln = "target",
  cellID_coln = 'CellId',
  spatLocs_colns = c('x','y','z'),
  extracellular_cellID = 0 
)

# case 2: use `refProfiles` to get `clust`, use `transcript_df` directly, 
# unknown distance cutoffs
prep_res2 <- runPreprocess(
  counts = example_CellGeneExpr,
  clust = NULL,
  refProfiles = example_refProfiles,
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum= NULL,
  
  # impute for cell types missing in provided 'transcript_df' 
  imputeFlag_missingCTs = TRUE, 
  
  ctrl_genes = NULL,
  svmClass_score_cutoff = -2,
  molecular_distance_cutoff = NULL,
  cellular_distance_cutoff = NULL,
  transcript_df = mini_transcriptDF, 
  transDF_fileInfo = NULL, 
  pixel_size = 0.18,
  zstep_size = 0.8, 
  transID_coln = NULL,
  transGene_coln = "target",
  cellID_coln = 'CellId',
  spatLocs_colns = c('x','y','z'),
  extracellular_cellID = 0 
)

# case 3: provide both `refProfiles` and `clust`, use transDF_fileInfo for 
# multi-files, no known molecular distance cutoffs
dataDir <- system.file("extdata", package = "FastReseg")
transDF_fileInfo <- data.frame(
  file_path = fs::path(dataDir,
                       c("Run4104_FOV001__complete_code_cell_target_call_coord.csv",
                         "Run4104_FOV002__complete_code_cell_target_call_coord.csv")),
  slide = c(1, 1),
  fov = c(1,2),
  stage_X = 1000*c(5.13, -2.701),
  stage_Y = 1000*c(-0.452, 0.081))
prep_res3 <- runPreprocess(
  counts = example_CellGeneExpr,
  clust = example_clust,
  refProfiles = example_refProfiles,
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum= NULL,
  imputeFlag_missingCTs = TRUE,
  ctrl_genes = NULL,
  svmClass_score_cutoff = -2,
  molecular_distance_cutoff = NULL,
  cellular_distance_cutoff = 20,
  transcript_df = NULL, 
  transDF_fileInfo = transDF_fileInfo, 
  filepath_coln = 'file_path', 
  prefix_colns = c('slide','fov'), 
  fovOffset_colns = c('stage_X','stage_Y'), 
  pixel_size = 0.18,
  zstep_size = 0.8, 
  transID_coln = NULL,
  transGene_coln = "target",
  cellID_coln = 'CellId',
  spatLocs_colns = c('x','y','z'),
  extracellular_cellID = 0 
)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{runSegErrorEvaluation}{runSegErrorEvaluation}{runSegErrorEvaluation}
%
\begin{Description}
modular wrapper to flag cell segmentation error
\end{Description}
%
\begin{Usage}
\begin{verbatim}
runSegErrorEvaluation(
  score_GeneMatrix,
  transcript_df,
  cellID_coln = "UMI_cellID",
  transID_coln = "UMI_transID",
  transGene_coln = "target",
  spatLocs_colns = c("x", "y", "z"),
  flagModel_TransNum_cutoff = 50
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{score\_GeneMatrix}] the gene x cell-type matrix of log-like score of gene in each cell type

\item[\code{transcript\_df}] the data.frame of transcript\_ID, cell\_ID, score, spatial coordinates

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transGene\_coln}] the column name of target or gene name in transcript\_df

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in transcript\_df

\item[\code{flagModel\_TransNum\_cutoff}] the cutoff of transcript number to do spatial modeling for identification of wrongly segmented cells (default = 50)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list of two elements
\#' \begin{enumerate}

\item{} modStats\_ToFlagCells, a data.frame contains evaluation model statistics in columns for each cell's potential to have segmentation error
\item{} transcript\_df, transcript data.frame with 2 additional columns: \code{tLLR\_maxCellType} for cell types of maxmium transcript score under current segments and \code{score\_tLLR\_maxCellType} for the corresponding transcript score for each transcript

\end{enumerate}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data("mini_transcriptDF")
data("example_CellGeneExpr")
data("example_refProfiles")
score_GeneMatrix <- scoreGenesInRef(
  genes = intersect(colnames(example_CellGeneExpr), rownames(example_refProfiles)), 
  ref_profiles = pmax(example_refProfiles, 1e-5))

res <- runSegErrorEvaluation(
  score_GeneMatrix= score_GeneMatrix, 
  transcript_df = mini_transcriptDF, 
  cellID_coln = 'UMI_cellID', 
  transID_coln = 'UMI_transID',
  transGene_coln = 'target',
  spatLocs_colns = c('x','y','z'),
  #' cutoff of transcript number to do spatial modeling
  flagModel_TransNum_cutoff = 50) 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{runSegRefinement}{runSegRefinement}{runSegRefinement}
%
\begin{Description}
modular wrapper to evalute transcript groups in neighborhood, decide resegmentation operations and execute
\end{Description}
%
\begin{Usage}
\begin{verbatim}
runSegRefinement(
  score_GeneMatrix,
  chosen_cells = NULL,
  reseg_transcript_df,
  reseg_cellID_coln = "tmp_cellID",
  reseg_celltype_coln = "group_maxCellType",
  transID_coln = "transcript_id",
  transGene_coln = "target",
  transSpatLocs_coln = c("x", "y", "z"),
  score_baseline = NULL,
  lowerCutoff_transNum = NULL,
  higherCutoff_transNum = NULL,
  neighbor_distance_xy = NULL,
  distance_cutoff = 2.7,
  spatialMergeCheck_method = c("leidenCut", "geometryDiff"),
  cutoff_spatialMerge = 0.5,
  leiden_config = list(objective_function = c("CPM", "modularity"), resolution_parameter
    = 1, beta = 0.01, n_iterations = 200),
  config_spatNW_transcript = NULL,
  return_intermediates = TRUE,
  return_perCellData = TRUE,
  includeAllRefGenes = FALSE,
  seed_segRefine = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{score\_GeneMatrix}] the gene x cell-type matrix of log-like score of gene in each cell type

\item[\code{chosen\_cells}] the cell\_ID of chosen cells need to be evaluate for re-segmentation

\item[\code{reseg\_transcript\_df}] the data.frame with transcript\_id, target/geneName, x, y, cell\_id for all transcript groups and the cell type of maximum transcript scores for each transcript group

\item[\code{reseg\_cellID\_coln}] the column name of cell\_ID for all transcript groups in transcript\_df

\item[\code{reseg\_celltype\_coln}] the column name of cell\_type for all transcript groups in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transGene\_coln}] the column name of target or gene name in transcript\_df

\item[\code{transSpatLocs\_coln}] the column name of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df

\item[\code{score\_baseline}] a named vector of score baseline for all cell type listed in neighborhood\_df such that per cell transcript score higher than the baseline is required to call a cell type of high enough confidence

\item[\code{lowerCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that higher than the cutoff is required to keep query cell as it is

\item[\code{higherCutoff\_transNum}] a named vector of transcript number cutoff under each cell type such that lower than the cutoff is required to keep query cell as it is when there is neighbor cell of consistent cell type.

\item[\code{neighbor\_distance\_xy}] maximum cell-to-cell distance in x, y between the center of query cells to the center of neighbor cells with direct contact, same unit as input spatial coordinate. Default = NULL to use the 2 times of average 2D cell diameter.

\item[\code{distance\_cutoff}] maximum molecule-to-molecule distance within connected transcript group, same unit as input spatial coordinate (default = 2.7 micron).
If set to NULL, the pipeline would first randomly choose no more than 2500 cells from up to 10 random picked ROIs with search radius to be 5 times of \code{neighbor\_distance\_xy}, and then calculate the minimal molecular distance between picked cells. The pipeline would further use the 5 times of 90\% quantile of minimal molecular distance as \code{distance\_cutoff}. This calculation is slow and is not recommended for large transcript data.frame.

\item[\code{spatialMergeCheck\_method}] use either "leidenCut" (in 2D or 3D) or "geometryDiff" (in 2D only) method to determine whether a cell pair merging event is allowed in space (default = "leidenCut")

\item[\code{cutoff\_spatialMerge}] spatial constraint on a valid merging event between two source transcript groups, default = 0.5 for 50\% cutoff, set to 0 to skip spatial constraint evaluation for merging.
For \code{spatialMergeCheck\_method = "leidenCut"}, this is the minimal percentage of transcripts shared membership between query cell and neighbor cells in leiden clustering results for a valid merging event.
For \code{spatialMergeCheck\_method = "geometryDiff"}, this is the maximum percentage of white space change upon merging of query cell and neighbor cell for a valid merging event.

\item[\code{leiden\_config}] (leidenCut) a list of configuration to pass to reticulate and \code{igraph::cluster\_leiden} function, including objective\_function, resolution\_parameter, beta, n\_iterations.

\item[\code{config\_spatNW\_transcript}] (leidenCut) configuration list to create spatial network at transcript level, see manual for \code{createSpatialDelaunayNW\_from\_spatLocs} for more details, set to NULL to use default config

\item[\code{return\_intermediates}] flag to return intermediate outputs, including \code{neighborhoodDF\_ToReseg} data.frame for neighborhood evaluation, \code{reseg\_actions} list of resegmentation actions

\item[\code{return\_perCellData}] flag to return gene x cell count matrix and per cell DF with updated mean spatial coordinates and new cell type

\item[\code{includeAllRefGenes}] flag to include all genes in \code{score\_GeneMatrix} in the returned \code{updated\_perCellExprs} with missing genes of value 0 (default = FALSE)

\item[\code{seed\_segRefine}] seed for transcript error correction step, default = NULL to skip the seed
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list
\begin{description}

\item[updated\_transDF] the updated transcript\_df with \code{updated\_cellID} and \code{updated\_celltype} columns based on reseg\_full\_converter
\item[neighborhoodDF\_ToReseg] a data.frame for neighborhood environment of low-score transcript groups, output of \code{get\_neighborhood\_content} function, return when \code{return\_intermediates} = TRUE
\item[reseg\_actions] a list of 4 elements describing how the resegmenation would be performed on original \code{transcript\_df} by the group assignment of transcripts listed in \code{groupDF\_ToFlagTrans}, output of \code{decide\_ReSegment\_Operations} function, return when \code{return\_intermediates} = TRUE
\item[updated\_perCellDT] a per cell data.table with mean spatial coordinates, new cell type and resegmentation action after resegmentation, return when \code{return\_perCellData} = TRUE
\item[updated\_perCellExprs] a gene x cell count sparse matrix for updated transcript data.frame after resegmentation, return when \code{return\_perCellData} = TRUE

\end{description}

\end{Value}
\inputencoding{utf8}
\HeaderA{runTranscriptErrorDetection}{runTranscriptErrorDetection}{runTranscriptErrorDetection}
%
\begin{Description}
modular wrapper to identify transcript groups of poor fit to current cell segments in space
\end{Description}
%
\begin{Usage}
\begin{verbatim}
runTranscriptErrorDetection(
  chosen_cells,
  score_GeneMatrix,
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  transGene_coln = "target",
  score_coln = "score",
  spatLocs_colns = c("x", "y", "z"),
  model_cutoff = 50,
  score_cutoff = -2,
  svm_args = list(kernel = "radial", scale = FALSE, gamma = 0.4),
  groupTranscripts_method = c("dbscan", "delaunay"),
  distance_cutoff = "auto",
  config_spatNW_transcript = NULL,
  seed_transError = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_cells}] the cell\_ID of chosen cells

\item[\code{score\_GeneMatrix}] the gene x cell-type matrix of log-like score of gene in each cell type

\item[\code{transcript\_df}] the data.frame of transcript\_ID, cell\_ID, score, spatial coordinates

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{transGene\_coln}] the column name of target or gene name in transcript\_df

\item[\code{score\_coln}] the column name of score in transcript\_df

\item[\code{spatLocs\_colns}] the column names of 1st, 2nd, optional 3rd spatial dimension of each transcript in transcript\_df

\item[\code{model\_cutoff}] the cutoff of transcript number to do spatial modeling (default = 50)

\item[\code{score\_cutoff}] the cutoff of score to separate between high and low score transcripts (default = -2)

\item[\code{svm\_args}] a list of arguments to pass to svm function, typically involve kernel, gamma, scale

\item[\code{groupTranscripts\_method}] use either "dbscan" or "delaunay" method to group transcripts in space (default = "dbscan")

\item[\code{distance\_cutoff}] maximum molecule-to-molecule distance within same transcript group (default = "auto")

\item[\code{config\_spatNW\_transcript}] configuration list to create spatial network at transcript level, see manual for \code{createSpatialDelaunayNW\_from\_spatLocs} for more details, set to NULL to use default config

\item[\code{seed\_transError}] seed for transcript error detection step, default = NULL to skip the seed
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data frame for transcripts in \code{chosen\_cells} only, containing information for transcript score classifications and spatial group assignments as well as new cell/group ID for downstream resegmentation.
\end{Value}
\inputencoding{utf8}
\HeaderA{scoreGenesInRef}{scoreGenesInRef}{scoreGenesInRef}
%
\begin{Description}
calculate log-likilhood score of each gene based on reference expression profiles and return the centered score matrix
\end{Description}
%
\begin{Usage}
\begin{verbatim}
scoreGenesInRef(genes, ref_profiles, flag_center = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{genes}] a vector of gene name to score

\item[\code{ref\_profiles}] a gene X cell\_type expression matrix for reference profiles

\item[\code{flag\_center}] flag to center the score matrix per gene before return, default = TRUE
\end{ldescription}
\end{Arguments}
%
\begin{Value}
loglik, a gene X cell\_type matrix of centered loglik score for each gene
\end{Value}
\inputencoding{utf8}
\HeaderA{score\_cell\_segmentation\_error}{score\_cell\_segmentation\_error}{score.Rul.cell.Rul.segmentation.Rul.error}
%
\begin{Description}
Score each cell for how much their transcripts change their goodness-of-fit over space.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
score_cell_segmentation_error(
  chosen_cells,
  transcript_df,
  cellID_coln = "CellId",
  transID_coln = "transcript_id",
  score_coln = "score",
  spatLocs_colns = c("x", "y", "z"),
  model_cutoff = 50
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{chosen\_cells}] the cell\_ID of chosen cells

\item[\code{transcript\_df}] the data.frame of transcript\_ID, cell\_ID, score, spatial coordinates

\item[\code{cellID\_coln}] the column name of cell\_ID in transcript\_df

\item[\code{transID\_coln}] the column name of transcript\_ID in transcript\_df

\item[\code{score\_coln}] the column name of score in transcript\_df

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in transcript\_df

\item[\code{model\_cutoff}] the cutoff of transcript number to do spatial modeling (default = 50)
\end{ldescription}
\end{Arguments}
%
\begin{Details}
For tLLRv2 score of transcripts within each cell,  run a quadratic model: mod\_alternative = lm(tLLRv2 \textasciitilde{} x + y + x2 + y2 +xy) for 2D,  lm(tLLRv2 \textasciitilde{} x + y + z + x2 + y2 +z2 +xy + xz + yz) for 3D and a null model: mod\_null = lm(tLLRv2 \textasciitilde{} 1); then run lmtest::lrtest(mod\_alternative, mod\_null). Return statistics for mod\_alternative\$fitted.values (standard deviation and minimal value), summary(mod\_alternative)\$r.squared and as well as lrtest chi-squared value.
\end{Details}
%
\begin{Value}
data.frame with columns for
\begin{enumerate}

\item{} cell\_ID, cell id
\item{} transcript\_num, number of transcripts in given cell
\item{} modAlt\_rsq, summary(mod\_alternative)\$r.squared
\item{} lrtest\_ChiSq, lrtest chi-squared value
\item{} lrtest\_Pr, lrtest probability larger than chi-squared value, p-value

\end{enumerate}

\end{Value}
\inputencoding{utf8}
\HeaderA{transDF\_to\_perCell\_data}{transDF\_to\_perCell\_data}{transDF.Rul.to.Rul.perCell.Rul.data}
%
\begin{Description}
get per cell expression matrix and optional metadata like mean spatial coordinates and cell types from transcript data.frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
transDF_to_perCell_data(
  transcript_df,
  transGene_coln = "target",
  cellID_coln = "updated_cellID",
  spatLocs_colns = c("x", "y", "z"),
  celltype_coln = "updated_celltype",
  return_cellMeta = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{transcript\_df}] transcript data.frame

\item[\code{transGene\_coln}] column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] column name of cell\_ID in \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in \code{transcript\_df}

\item[\code{celltype\_coln}] column name for cell type in \code{transcript\_df}

\item[\code{return\_cellMeta}] flag to return per cell data.table for metadata like mean spatial coordinates and cell types
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list
\begin{description}

\item[perCell\_DT] a per cell data.table with mean spatial coordinates, cell type, return when \code{return\_cellMeta} = TRUE
\item[perCell\_expression] a gene x cell count sparse matrix derived from transcript data.frame after resegmentation

\end{description}

\end{Value}
\inputencoding{utf8}
\HeaderA{update\_transDF\_ResegActions}{update\_transDF\_ResegActions}{update.Rul.transDF.Rul.ResegActions}
%
\begin{Description}
Update transcript data.frame based on resegmentation action, calculate the new cell type and mean per cell spatial coordinates
\end{Description}
%
\begin{Usage}
\begin{verbatim}
update_transDF_ResegActions(
  transcript_df,
  reseg_full_converter,
  score_GeneMatrix,
  transGene_coln = "target",
  cellID_coln = "cell_ID",
  celltype_coln = "cell_type",
  spatLocs_colns = c("x", "y", "z"),
  return_perCellDF = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{transcript\_df}] the data.frame of transcript to be updated

\item[\code{reseg\_full\_converter}] a named converter to update the cell ID in \code{transcript\_df}, cell\_ID in name would be converted to cell\_ID in value; discard cell\_ID with value = NA

\item[\code{score\_GeneMatrix}] a gene x cell-type score matrix

\item[\code{transGene\_coln}] the column name of target or gene name in \code{transcript\_df}

\item[\code{cellID\_coln}] the column name of cell\_ID in \code{transcript\_df}

\item[\code{celltype\_coln}] the column name of cell type in \code{transcript\_df}

\item[\code{spatLocs\_colns}] column names for 1st, 2nd and optional 3rd dimension of spatial coordinates in transcript\_df

\item[\code{return\_perCellDF}] flag to return gene x cell count matrix and per cell DF with updated mean spatial coordinates and new cell type
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Update transcript data.frame based on resegmentation action and get new cell type; when return\_perCellDF = TRUE, return gene x cell count matrix and per cell data.frame with mean per cell spatial coordinates and new cell type.
\end{Details}
%
\begin{Value}
a list
\begin{description}

\item[updated\_transDF] the updated transcript\_df with \code{updated\_cellID} and \code{updated\_celltype} column based on reseg\_full\_converter
\item[perCell\_DT] a per cell data.table with mean spatial coordinates and new cell type when return\_perCellDF = TRUE
\item[perCell\_expression] a gene x cell count sparse matrix for updated transcript data.frame when return\_perCellDF = TRUE

\end{description}

\end{Value}
\printindex{}
\end{document}
